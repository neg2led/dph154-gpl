/*
 * Utility code which helps transforming between hardware time stamps
 * generated by a clocksource and system time. The clocksource is
 * assumed to return monotonically increasing time (but this code does
 * its best to compensate if that is not the case) whereas system time
 * may jump.
 */
#ifndef _LINUX_CLOCKSYNC_H
#define _LINUX_CLOCKSYNC_H

#include <linux/clocksource.h>
#include <linux/ktime.h>

/**
 * struct clocksync - stores state and configuration for the two clocks
 *
 * Initialize to zero, then set clock, systime, num_samples.
 *
 * Transformation between HW time and system time is done with:
 * HW time transformed = HW time + offset +
 *                       (HW time - last_update) * skew / CLOCKSYNC_SKEW_RESOLUTION
 *
 * @clock:           the source for HW time stamps (%clocksource_read_time)
 * @systime:         function returning current system time (ktime_get
 *                   for monotonic time, or ktime_get_real for wall clock)
 * @num_samples:     number of times that HW time and system time are to
 *                   be compared when determining their offset
 * @offset:          (system time - HW time) at the time of the last update
 * @skew:            average (system time - HW time) / delta HW time *
 *                   CLOCKSYNC_SKEW_RESOLUTION
 * @last_update:     last HW time stamp when clock offset was measured
 */
struct clocksync {
	struct clocksource *clock;
	ktime_t (*systime)(void);
	int num_samples;

	s64 offset;
	s64 skew;
	u64 last_update;
};

/**
 * CLOCKSYNC_SKEW_RESOLUTION - fixed point arithmetic scale factor for skew
 *
 * Usually one would measure skew in ppb (parts per billion, 1e9), but
 * using a factor of 2 simplifies the math.
 */
#define CLOCKSYNC_SKEW_RESOLUTION (((s64)1)<<30)

/**
 * clocksync_hw2sys - transform HW time stamp into corresponding system time
 * @sync:             context for clock sync
 * @hwtstamp:         the result of %clocksource_read_time or
 *                    %clocksource_cyc2time
 */
static inline ktime_t clocksync_hw2sys(struct clocksync *sync,
					u64 hwtstamp)
{
	u64 nsec;

	nsec = hwtstamp + sync->offset;
	nsec += (s64)(hwtstamp - sync->last_update) * sync->skew /
		CLOCKSYNC_SKEW_RESOLUTION;

	return ns_to_ktime(nsec);
}

/**
 * clocksync_offset - measure current (system time - HW time) offset
 * @sync:             context for clock sync
 * @offset:           average offset during sample period returned here
 * @hwtstamp:         average HW time during sample period returned here
 *
 * Returns number of samples used. Might be zero (= no result) in the
 * unlikely case that system time was monotonically decreasing for all
 * samples (= broken).
 */
int clocksync_offset(struct clocksync *sync,
		s64 *offset,
		u64 *hwtstamp);

/**
 * clocksync_update - update offset and skew by measuring current offset
 * @sync:             context for clock sync
 * @hwtstamp:         the result of %clocksource_read_time or
 *                    %clocksource_cyc2time, pass zero to force update
 *
 * Updates are only done at most once per second.
 */
static inline void clocksync_update(struct clocksync *sync,
			u64 hwtstamp)
{
	s64 offset;
	u64 average_time;

	if (hwtstamp &&
		(s64)(hwtstamp - sync->last_update) < NSEC_PER_SEC)
		return;

	if (!clocksync_offset(sync, &offset, &average_time))
		return;

	printk(KERN_DEBUG
		"average offset: %lld\n", offset);

	if (!sync->last_update) {
		sync->last_update = average_time;
		sync->offset = offset;
		sync->skew = 0;
	} else {
		s64 delta_nsec = average_time - sync->last_update;

		/* avoid division by negative or small deltas */
		if (delta_nsec >= 10000) {
			s64 delta_offset_nsec = offset - sync->offset;
			s64 skew = delta_offset_nsec *
				CLOCKSYNC_SKEW_RESOLUTION /
				delta_nsec;

			/**
			 * Calculate new overall skew as 4/16 the
			 * old value and 12/16 the new one. This is
			 * a rather arbitrary tradeoff between
			 * only using the latest measurement (0/16 and
			 * 16/16) and even more weight on past measurements.
			 */
#define CLOCKSYNC_NEW_SKEW_PER_16 12
			sync->skew =
				((16 - CLOCKSYNC_NEW_SKEW_PER_16) * sync->skew +
					CLOCKSYNC_NEW_SKEW_PER_16 * skew) /
				16;
			sync->last_update = average_time;
			sync->offset = offset;
		}
	}
}

#endif /* _LINUX_CLOCKSYNC_H */
