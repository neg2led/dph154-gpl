/*****************************************************************************
 * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
 *****************************************************************************/

/*!
* \file spi.c
* \brief SPI driver for the PC302.
*
* Copyright (c) 2006-2009 picoChip Designs Ltd
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*
* All enquiries to support@picochip.com
*/

/* Includes ---------------------------------------------------------------- */
#include <common.h>

#ifdef CFG_DW_SPI

/* Define this to use a GPIO as the spi flash chip select.
   Note: On the PC7302 platform we only have a single spi flash device.
   Note: If this is not defined then we use the chip select generated by the
         SPI block.
   Note: Using this option on a PC7302 platform will require a board
         modification.
*/
//#define USE_GPIO_AS_CHIP_SELECT

#include <spi.h>
#include <malloc.h>
#include <asm/io.h>
#include <asm/arch/pc302.h>
#include <asm/arch/spi.h>
#include <asm/arch/axi2cfg.h>
#include <asm/arch/gpio.h>

/* Macros ------------------------------------------------------------------ */
/*!
 * \brief Debug macro
 */
#ifdef	SPI_DEBUG
#define spi_debug(fmt,args...)	printf (fmt ,##args)
#else
#define spi_debug(fmt,args...)
#endif	/* SPI_DEBUG */

/* !
 *  \brief Macros used to read from, and write to, the spi registers.
 *         Note: These macros provide 16 bit access.
 */
#define SPI_READ(__offset) \
                  *((volatile u16*)(PC302_SSI_BASE + __offset))

#define SPI_WRITE(__value, __offset) \
                   *((volatile u16*)(PC302_SSI_BASE + __offset)) = __value

/* !
 *  \brief Macros used to read from, and write to, the axi2cfg registers.
 *         Note: These macros provide 32 bit access.
 */
#define AXI2CFG_READ(__offset) \
                  *((volatile u32*)(PC302_AXI2CFG_BASE + __offset))

#define AXI2CFG_WRITE(__value, __offset) \
                   *((volatile u32*)(PC302_AXI2CFG_BASE + __offset)) = __value

/* Constants --------------------------------------------------------------- */
/* !
 *  \brief This structure is used for generic and device specific
 *         spi driver data.
 */
struct pc302_spi_slave
{
    /* Generic spi slave description */
    struct spi_slave slave;

    /* Additional driver data for the pc302 implementation */

    /* Serial clock polarity */
    unsigned int scpol;

    /* Serial clock phase */
    unsigned int scph;

    /* Serial bus speed (Hz) */
    unsigned int max_hz;

    /* Pointer to hold location of the Tx data 'copy' */
    u8 * dout_copy;

    /* Keep a count of the data to tx */
    unsigned int byte_count_tx;
};

/*!
 * \brief Function return codes
 */
enum return_codes
{
    SUCCESS = 0,    /* Successful outcome */
    FAILURE = 1     /* Error response */
};

/* Types ------------------------------------------------------------------- */

/* Prototypes--------------------------------------------------------------- */

void spi_init()
{
    /* Nothing specific required in here */
}

struct spi_slave *spi_setup_slave(unsigned int bus,
                                  unsigned int cs,
                                  unsigned int max_hz,
                                  unsigned int mode)
{
    struct pc302_spi_slave  *spi_slave;

    unsigned int    spi_max_clock = 0;
    unsigned int    spi_min_clock = 0;

    /* Have we been passed a valid combination of bus and cs ?
       Note: PC302 device has a single SPI controller (bus) and
             4 possible SPI chip selects */

    if (bus > (PC302_MAX_NUMBER_SPI_BUSSES - 1))
    {
        /* Oops, request bus is out of range. */
        printf ("Oops, SPI 'bus' out of range. "
                "(We only have %d SPI bus(ses) available).\n",
                (unsigned int)PC302_MAX_NUMBER_SPI_BUSSES);
        return NULL;
    }

    if (cs > (PC302_MAX_NUMBER_SPI_CS - 1))
    {
        /* Oops, requested chip select is out of range */
        printf ("Oops, SPI 'cs' out of range. "
                "(We only have %d 'cs' available).\n",
                (unsigned int)PC302_MAX_NUMBER_SPI_CS);
        return NULL;
    }

    /* Have we been passed a valid SPI bus clock rate ? */
    spi_max_clock = (PC302_AHB_CLOCK_FREQ / PC302_MIN_SPI_CLK_DIVIDER);
    spi_min_clock = (PC302_AHB_CLOCK_FREQ / PC302_MAX_SPI_CLK_DIVIDER);

    if ((max_hz < spi_min_clock) || (max_hz > spi_max_clock))
    {
    	/* Oops, we do not support this requested SPI bus clock rate */
        printf ("Oops, SPI bus 'hz' out of range. "
                "(Min = %d Hz, Max = %d Hz).\n", spi_min_clock, spi_max_clock);
	return NULL;
    }

#ifdef USE_GPIO_AS_CHIP_SELECT
    /* Have we been passed a valid SPI mode ? */
    if ((mode < SPI_MODE_0) || (mode > SPI_MODE_3))
    {
        /* Oops, we only support spi mode 0 - 3 */
        printf ("Oops, SPI 'mode' out of range. "
                "(We only support SPI 'mode' %d to %d).\n",
                (unsigned int)SPI_MODE_0, (unsigned int)SPI_MODE_3);
        return NULL;
    }
#else
    /* Have we been passed a valid SPI mode ? */
    if (mode != SPI_MODE_3)
    {
        /* Oops, we only support spi mode 3 */
        printf ("Oops, SPI 'mode' out of range. "
                "(We only support SPI 'mode' %d).\n",
                (unsigned int)SPI_MODE_3);
        return NULL;
    }
#endif

    /* Grab some memory for the SPI data structure */
    spi_slave = malloc(sizeof(struct pc302_spi_slave));
    if (!spi_slave)
    {
        /* Oops, we have a memory management problem */
	printf ("Oops, memory allocation error, File: %s, Function: %s,"
                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
        return NULL;
    }

    /* Populate our structure */
    spi_slave->slave.bus = bus;
    spi_slave->slave.cs = cs;
    spi_slave->max_hz = max_hz;

    switch (mode)
    {
        case SPI_MODE_0:
            spi_slave->scpol = 0;
            spi_slave->scph = 0;
            break;
        case SPI_MODE_1:
            spi_slave->scpol = 0;
            spi_slave->scph = 1;
            break;
        case SPI_MODE_2:
            spi_slave->scpol = 1;
            spi_slave->scph = 0;
            break;
        case SPI_MODE_3:
            spi_slave->scpol = 1;
            spi_slave->scph = 1;
            break;
        default:
            spi_slave->scpol = 0;
            spi_slave->scph = 0;
            break;
    }

#ifdef USE_GPIO_AS_CHIP_SELECT
    /* Set up ARM gpio #2 for cs driving */
    /* Negate the 'cs' in the data register */
    *(unsigned int *)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
                      GPIO_BIT_2;

    /* Set up the gpio as an o/p */
    *(unsigned int *)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DDR_REG_OFFSET) |=
                      GPIO_BIT_2;
#endif

    return &spi_slave->slave;
}

void spi_free_slave(struct spi_slave *slave)
{
    struct pc302_spi_slave  *spi_slave =
           container_of(slave, struct pc302_spi_slave, slave);

    /* Free memory acquired to hold the SPI data structure */
    free (spi_slave);
}

int spi_claim_bus(struct spi_slave *slave)
{
    struct pc302_spi_slave  *spi_slave;

    u16 ctrlr0 = 0;
    u16 sckdv = 0;

     /* Have we been passed a valid data structure handle ? */
    if (slave == NULL)
    {
        /* Oops, bad handle passed in */
        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
        return -FAILURE;
    }

    spi_slave = container_of(slave, struct pc302_spi_slave, slave);

    /* Disable SPI operations
       Note: We can't program up the block registers unless
             the block is disabled  */
    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);

    /* Program up some bits Control Register 0.
       Note: As TMOD bits set to 00 (Transmit & Receive),
             we do not need to worry about the ctrlr1 register */
    ctrlr0 = PC302_SPI_DATA_FRM_8_BIT;

    if (spi_slave->scph)
    {
        /* Set the clock phase */
        ctrlr0 |= PC302_SPI_SCPH;
    }
    if (spi_slave->scpol)
    {
        /* Set the clock polarity */
        ctrlr0 |= PC302_SPI_SCPOL;
    }
    SPI_WRITE(ctrlr0, SSI_CTRL_REG_0_REG_OFFSET);

    /* Setup the SPI bus clock rate */
    sckdv = (PC302_AHB_CLOCK_FREQ / spi_slave->max_hz);
    SPI_WRITE(sckdv, SSI_BAUD_RATE_SEL_REG_OFFSET);

    /* Mask all interrupts from the SPI block */
    SPI_WRITE(PC302_SPI_MASK_ALL_INTS, SSI_IMR_REG_OFFSET);

    return SUCCESS;
}

void spi_release_bus(struct spi_slave *slave)
{
    /* Have we been passed a valid data structure handle ? */
    if (slave == NULL)
    {
        /* Oops, bad handle passed in */
        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
    }

    /* Disable SPI operations */
    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
}

int spi_xfer(struct spi_slave *slave,
             unsigned int bitlen,
             const void *dout,
             void *din,
             unsigned long flags)
{
    struct pc302_spi_slave  *spi_slave;

    unsigned int    len_tx;
    unsigned int    len_rx;
    unsigned int    byte_count;

    u16		    status;

    const u8	    *txp = dout;
    u8		    *rxp = din;
    u8		    value;


    spi_debug ("spi_xfer: bitlen = %d, dout = %p, din = %p, flags = %d\n",
                bitlen, dout, din, flags);

     /* Have we been passed a valid data structure handle ? */
    if (slave == NULL)
    {
        /* Oops, bad handle passed in */
        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
        return -FAILURE;
    }

    spi_slave = container_of(slave, struct pc302_spi_slave, slave);

    if (bitlen == 0)
    {
        /* Finish any previously submitted transfers */
	goto out;
    }

    /*
     * The SPI controller can do non-multiple-of-8 bit
     * transfers, but this driver currently doesn't support it.
     */
    if (bitlen % 8)
    {
        /* Errors always terminate an ongoing transfer */
	flags |= SPI_XFER_END;
        goto out;
    }

    /* Number of bytes to transfer */
    byte_count = bitlen / 8;

#ifdef USE_GPIO_AS_CHIP_SELECT
    /* Ok, we are using a chip select generated by a gpio signal */

    if (flags & SPI_XFER_BEGIN)
    {
        /* Assert the required chip SPI slave chip select */
        spi_cs_activate(slave);

        /* Enable SPI operations */
        SPI_WRITE(PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
    }

    /* Start the data transfer */
    for (len_tx = 0, len_rx = 0; len_rx < byte_count; )
    {
        status = SPI_READ(SSI_STATUS_REG_OFFSET);

	if (len_tx < byte_count && (status & PC302_SPI_STATUS_TFNF))
        {
	    /* We have room in the Tx fifo */
            if (txp)
		value = *txp++;
	    else
		value = 0;

            SPI_WRITE(value, SSI_DATA_REG_OFFSET);
            len_tx++;
	}

        if (status & PC302_SPI_STATUS_RFNE)
        {
	    /* We have some data in the receive fifo */
            value = (u8)SPI_READ(SSI_DATA_REG_OFFSET);
	    if (rxp)
	        *rxp++ = value;
	    len_rx++;
	}
    }

out:
    if (flags & SPI_XFER_END)
    {
        /*
	 * Wait until the transfer is completely done before
	 * we deactivate CS.
	 */
        do
        {
	    status = SPI_READ(SSI_STATUS_REG_OFFSET);
            status &= PC302_SPI_STATUS_BUSY;

	} while (status);

	spi_cs_deactivate(slave);
    }

    return SUCCESS;
}
#else   /* USE_GPIO_AS_CHIP_SELECT */

    /* Using the SPI block to control the chip selects,
       therefore we need all transactions before we start anything.

       Note: It is imperative that the Tx fifo never empties during operation,
             if this happens the cs will be negated by the SPI block,
             the spi flash will 'forget' what it is doing and it will
             all end in tears ! */

    u8 *dout_copy = NULL;
    unsigned int byte_count_tx = 0;
    unsigned int byte_count_rx = 0;
    unsigned int byte_count_tx_more = 0;
    unsigned int total_loop_count = 0;
    unsigned int total_tx_count = 0;

    if (flags & SPI_XFER_BEGIN)
    {
        /* If necessary take a copy of the data to transmit */
        if (txp)
        {
            /* Ok, we have some data to Tx */

            /* Grab some memory */
            dout_copy = malloc(byte_count);
            if (!dout_copy)
            {
                /* Oops, we have a memory management problem */
	        printf ("Oops, memory allocation error, File: %s,"
                        " Function: %s, Line: %d\n",
                        __FILE__, __FUNCTION__, __LINE__);
                return -FAILURE;
            }

            /* Lets take a copy of the data */
            memcpy (dout_copy, dout, byte_count);

            /* Save some useful info for later use */
            spi_slave->dout_copy = dout_copy;
            spi_slave->byte_count_tx = byte_count;

            /* We have a copy of the data so can null the
               tx data pointer */
            txp = NULL;
        }
    }

    if (flags & SPI_XFER_END)
    {
        /* Go retrieve the saved data */
        dout_copy = spi_slave->dout_copy;
        byte_count_tx = spi_slave->byte_count_tx ;

        if (!dout_copy)
        {
            /* Oops, we have a memory management problem */
	    printf ("Oops, memory allocation error, File: %s,"
                    " Function: %s, Line: %d\n",
                    __FILE__, __FUNCTION__, __LINE__);
            return -FAILURE;
        }

        /* Have we any more Tx data (spi flash writing) ? */
        if (txp)
        {
            byte_count_tx_more = byte_count;
        }
        else
        {
            byte_count_tx_more = 0;
        }

        /* Have we any data to Rx ? */
        if (rxp)
        {
            byte_count_rx = byte_count;
        }
        else
        {
            byte_count_rx = 0;
        }

        /* Assert the required chip SPI slave chip select */
        spi_cs_activate(slave);

        /* Enable SPI block operations */
        SPI_WRITE(PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);

        /* Set up some variables to avoid calculating them during the loop */
        total_loop_count = byte_count_rx + byte_count_tx + byte_count_tx_more;
        total_tx_count = byte_count_tx + byte_count_tx_more;

        spi_debug ("spi_xfer: byte_count_rx = %d\n", byte_count_rx);
        spi_debug ("spi_xfer: byte_count_tx = %d\n", byte_count_tx);
        spi_debug ("spi_xfer: byte_count_tx_more = %d\n", byte_count_tx_more);
        spi_debug ("spi_xfer: total_tx_count = %d\n", total_tx_count);
        spi_debug ("spi_xfer: total_loop_count = %d\n", total_loop_count);

        for (len_tx = 0, len_rx = 0; len_rx < total_loop_count; )
        {
	    status = SPI_READ(SSI_STATUS_REG_OFFSET);

            while (len_tx < byte_count_tx)
            {
	        /* The Tx fifo is 16 entries deep, we should never fill
                   this up sending a 'command' to the flash.  Therefore
                   we do not check the tx fifo status */
                SPI_WRITE(*dout_copy++, SSI_DATA_REG_OFFSET);
                len_tx++;
            }

            while ((len_tx < total_tx_count) &&
                   (status & PC302_SPI_STATUS_TFNF))
            {
                /* We have more data to Tx, so just keep going */
                SPI_WRITE(*txp++, SSI_DATA_REG_OFFSET);
                len_tx++;

                /* We may fill the tx fifo now, so a re-read of
                   the status register is a good idea */
                status = SPI_READ(SSI_STATUS_REG_OFFSET);
            }

            if ((len_tx >= total_tx_count) && (byte_count_rx == 0))
            {
                /* We have finished Tx and we are not interested in Rx,
                  lets get out of here */
                break;
            }

            if ((len_tx >= total_tx_count) && (byte_count_rx != 0))
            {
                /* Still trying to read some data, so keep the Tx fifo
                   tickling along, we don't care if the Tx fifo is
                   full or overflows */
                SPI_WRITE(0, SSI_DATA_REG_OFFSET);
            }

            if (status & PC302_SPI_STATUS_RFNE)
            {
	        /* We have some data available in the receive fifo */
                value = (u8)SPI_READ(SSI_DATA_REG_OFFSET);

                /* We do not want this data until it is 'valid',
                   i.e. we have finished transmitting all the Tx data */
                if (len_rx < total_tx_count)
                {
                    /* Just chuck the read data away */
                }
                else
                {
	            *rxp++ = value;
                }

                len_rx++;
	    }
        }
    }
out:
    if (flags & SPI_XFER_END)
    {
        /*
	 * If we have finished transmitting and we have no data to receive
         * wait until the transfer is completely done before we deactivate CS.
	 */
        if ((len_tx >= total_tx_count) && (byte_count_rx == 0))
        {
            /* Make sure the SPI block has actually started
               doing something... */
            udelay (500);

            do
            {
	        status = SPI_READ(SSI_STATUS_REG_OFFSET);
                status &= PC302_SPI_STATUS_BUSY;

	    } while (status);
        }

	spi_cs_deactivate(slave);

        if (spi_slave->dout_copy)
        {
            free(spi_slave->dout_copy);
            spi_slave->dout_copy = NULL;
        }

        spi_slave->byte_count_tx = 0;
    }

    return SUCCESS;

}
#endif  /* USE_GPIO_AS_CHIP_SELECT */

void spi_cs_activate(struct spi_slave *slave)
{
    struct pc302_spi_slave  *spi_slave;
    u16 chip_select = 0;
    u32 system_config = 0;

    /* Have we been passed a valid data structure handle ? */
    if (slave == NULL)
    {
        /* Oops, bad handle passed in */
        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
        return;
    }

    spi_slave = container_of(slave, struct pc302_spi_slave, slave);

    /* Make sure the SPI is disabled */
    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);

    /* Obtain the chip select are we using */
    chip_select =  (u16)spi_slave->slave.cs;

    /* Write to the Slave Enable Register */
    SPI_WRITE((1 << chip_select), SSI_SLAVE_ENABLE_REG_OFFSET);

    /* Sort out the SPI/EBI chip select muxing.
       Note: Set all chip select muxing to be SPI */
    system_config = AXI2CFG_READ(AXI2CFG_SYS_CONFIG_REG_OFFSET);
    system_config &= ~(AXI2CFG_DECODE_MUX_0 |
                       AXI2CFG_DECODE_MUX_1 |
                       AXI2CFG_DECODE_MUX_2 |
                       AXI2CFG_DECODE_MUX_3);

    AXI2CFG_WRITE(system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);

#ifdef USE_GPIO_AS_CHIP_SELECT
    /* Assert the 'cs' */
    *(unsigned int*)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) &=
                     ~(GPIO_BIT_2);
#endif

}

void spi_cs_deactivate(struct spi_slave *slave)
{
    struct pc302_spi_slave  *spi_slave;
    u16 chip_select = 0;
    u32 system_config = 0;

    /* Have we been passed a valid data structure handle ? */
    if (slave == NULL)
    {
        /* Oops, bad handle passed in */
        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
        return;
    }

    spi_slave = container_of(slave, struct pc302_spi_slave, slave);

    /* Make sure the SPI is disabled */
    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);

    /* Obtain the chip select are we using */
    chip_select =  (u16)spi_slave->slave.cs;

    /* Write to the Slave Enable Register,
       Note: Just disable all chip selects for now */
    SPI_WRITE(PC302_SPI_SLAVES_DISABLE, SSI_SLAVE_ENABLE_REG_OFFSET);

    /* Sort out the SPI/EBI chip select muxing.
       Note: Set all chip select muxing to be EBI */
    system_config = AXI2CFG_READ(AXI2CFG_SYS_CONFIG_REG_OFFSET);
    system_config |= (AXI2CFG_DECODE_MUX_0 |
                      AXI2CFG_DECODE_MUX_1 |
                      AXI2CFG_DECODE_MUX_2 |
                      AXI2CFG_DECODE_MUX_3);

    AXI2CFG_WRITE(system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);

#ifdef USE_GPIO_AS_CHIP_SELECT
    /* Negate the 'cs' */
    *(unsigned int*)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
                     GPIO_BIT_2;
#endif

}

#endif /* CFG_DW_SPI */
