diff -Naur pico_1.3.4/Makefile ipa_1.3.4/Makefile
--- pico_1.3.4/Makefile	2011-04-26 11:53:20.000000000 +0100
+++ ipa_1.3.4/Makefile	2011-04-26 11:53:24.000000000 +0100
@@ -75,6 +75,18 @@
 # the object files are placed in the source directory.
 #
 
+ifeq ("$(TYPE)", "")
+#Nothing
+else
+IPA_FF_TYPE=$(TYPE)
+endif
+
+ifeq ("$(IPV)", "")
+#Nothing
+else
+IPA_VER=$(IPV)
+endif
+
 ifdef O
 ifeq ("$(origin O)", "command line")
 BUILD_DIR := $(O)
@@ -463,7 +475,8 @@
 unconfig:
 	@rm -f $(obj)include/config.h $(obj)include/config.mk \
 		$(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \
-		$(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep
+		$(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep \
+		$(obj)include/ipa_config.h
 
 #========================================================================
 # PowerPC
@@ -2268,6 +2281,19 @@
 sbc8641d_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) ppc mpc86xx sbc8641d
 
+ipaccessip202ff_config : unconfig
+	echo "ipa board type is $(IPA_FF_TYPE) and version id $(IPA_VER)"
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs ip202ff ipaccess pc20x $(IPA_FF_TYPE) $(IPA_VER)
+
+ipaccessip302ff_config : unconfig
+	echo "ipa board type is $(IPA_FF_TYPE) and version id $(IPA_VER)"
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs ip302ff ipaccess pc302 $(IPA_FF_TYPE) $(IPA_VER)
+
+# Nano-8
+ipaccess217_config : unconfig
+	echo "ipa board type is $(IPA_FF_TYPE) and version id $(IPA_VER)"
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs ip302ff ipaccess pc302 $(IPA_FF_TYPE) $(IPA_VER)
+
 #########################################################################
 ## 74xx/7xx Systems
 #########################################################################
diff -Naur pico_1.3.4/board/ipaccess/ip202ff/Makefile ipa_1.3.4/board/ipaccess/ip202ff/Makefile
--- pico_1.3.4/board/ipaccess/ip202ff/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip202ff/Makefile	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,41 @@
+#/*!
+#* \file Makefile
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= cpe20x.o cmd_ip202ff.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+# (uncomment these lines if want assembler for cmd_ip202ff - will break the build!)
+#cmd_ip202ff.o: cmd_ip202ff.c
+#	$(CC) $(CPPFLAGS) -S cmd_ip202ff.c
+	
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Naur pico_1.3.4/board/ipaccess/ip202ff/cmd_ip202ff.c ipa_1.3.4/board/ipaccess/ip202ff/cmd_ip202ff.c
--- pico_1.3.4/board/ipaccess/ip202ff/cmd_ip202ff.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip202ff/cmd_ip202ff.c	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,1555 @@
+/*
+ * (C) Copyright 2007 ip.access Ltd
+*/
+
+/*
+ * IP202FF platform timing/performance tests
+ *
+ * These tests are implemented as Board Specific U-boot commands.
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/pc20x.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/memif.h>
+
+
+#if defined(CONFIG_CMD_BSP)
+
+/* number of iteratios to run the read/write tests for */
+#define NUM_TEST_ITERATIONS     100000
+
+
+#define IOWRITE16(vALUE, aDDRESS)   *((volatile u16 *)(aDDRESS)) = (vALUE)
+#define IOREAD16(aDDRESS)           (*((volatile u16 *)(aDDRESS)))
+#define IOWRITE32(vALUE, aDDRESS)   *((volatile u32 *)(aDDRESS)) = (vALUE)
+#define IOREAD32(aDDRESS)           (*((volatile u32 *)(aDDRESS)))
+
+
+#define LED1_GPIO_NUM       2
+#define LED1_DATA_REG       (PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset)
+#define LED1_DIR_REG        (PC20X_GPIO_BASE + GpioPortADataDirectionRegOffset)
+
+#define LED2_GPIO_NUM       5
+#define LED2_DATA_REG       (PC20X_GPIO_BASE + GpioPortAOutputDataRegOffset)
+#define LED2_DIR_REG        (PC20X_GPIO_BASE + GpioPortADataDirectionRegOffset)
+
+#define TIMER_NUM           1
+
+
+typedef enum MemTypeTag
+{
+    MT_SDRAM = 0,
+    MT_SRAM,
+    MT_FLASH,
+
+    NUM_MTS,
+
+    MT_FULL_TEST
+}
+MemType;
+
+
+/*#define SHH_TEST*/
+#if defined(SHH_TEST)
+static void cp_delay (void)
+{
+    volatile int i;
+
+    /* copro seems to need some delay between reading and writing */
+    for (i = 0; i < 100; i++);
+}
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1 (void)
+{
+    unsigned long value;
+
+    __asm__ __volatile__(
+        "mrc    p15, 0, %0, c1, c0, 0   @ read control reg\n"
+        : "=r" (value)
+        :
+        : "memory");
+
+    return value;
+}
+
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1 (unsigned long value)
+{
+    __asm__ __volatile__(
+        "mcr    p15, 0, %0, c1, c0, 0   @ write it back\n"
+        :
+        : "r" (value)
+        : "memory");
+
+    read_p15_c1 ();
+}
+
+/* See also ARM926EJ-S Technical Reference Manual */
+#define C1_MMU      (1<<0)      /* mmu off/on */
+#define C1_ALIGN    (1<<1)      /* alignment faults off/on */
+#define C1_DC       (1<<2)      /* dcache off/on */
+
+#define C1_BIG_ENDIAN   (1<<7)      /* big endian off/on */
+#define C1_SYS_PROT (1<<8)      /* system protection */
+#define C1_ROM_PROT (1<<9)      /* ROM protection */
+#define C1_IC       (1<<12)     /* icache off/on */
+#define C1_HIGH_VECTORS (1<<13)     /* location of vectors: low/high addresses */
+
+void dcache_enable (void)
+{
+    ulong reg;
+
+    reg = read_p15_c1 ();       /* get control reg. */
+    cp_delay ();
+    write_p15_c1 (reg | C1_DC);
+}
+
+#endif  /* defined(SHH_TEST) */
+
+
+
+/*===========================================================================*/
+/* run the timcal command.
+ * This drives a LED low then high after a specified number of milliseconds.
+ * The tester should hook up the LED to a scope (or other timing device to
+ * time the pulse width.
+ */
+int do_timcal (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int             guardCount;
+    u32             gpioData;
+    u32             millisecondsForTest = 20;
+
+#if defined(SHH_TEST)
+printf ("Calling dcache_enable...\n");   /* SHH delete me!!! */
+dcache_enable ();   /* SHH delete me!!! */
+#endif  /* defined(SHH_TEST) */
+
+    switch (argc)
+    {
+    case 1:
+    case 2:
+        if (argc == 2)
+        {
+            int     dummy = simple_strtoul (argv[1], NULL, 10);
+            if ((dummy > 0) && (dummy <= 1000))
+            {
+                millisecondsForTest = dummy;
+            }
+            else
+            {
+                printf ("Bad milliseconds for test parameter - using %d\n", millisecondsForTest);
+            }
+        }
+
+        /* stop the timer */
+        IOWRITE32(0x0, PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+        /* load the count */
+        IOWRITE32((PC20X_AHB_CLOCK_FREQ/(1000/millisecondsForTest)),
+                  PC20X_TIMER_BASE + TimerNLoadCountRegOffset(TIMER_NUM));
+
+        /* set GPIO line to output for LED */
+        gpioData = IOREAD32(LED1_DIR_REG);
+        gpioData |= Gpio(LED1_GPIO_NUM);
+        IOWRITE32(gpioData, LED1_DIR_REG);
+
+        /* ensure LED is off */
+        gpioData = IOREAD32(LED1_DATA_REG);
+        gpioData &= ~Gpio(LED1_GPIO_NUM);
+        IOWRITE32(gpioData, LED1_DATA_REG);
+
+        guardCount = 1000000;
+        /* turn LED on */
+        gpioData |= Gpio(LED1_GPIO_NUM);
+        IOWRITE32(gpioData, LED1_DATA_REG);
+
+        /* start the timer in user defined count mode */
+        IOWRITE32((TimerEnable|TimerMode), PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+        while (--guardCount > 0)
+        {
+            if (IOREAD32(PC20X_TIMER_BASE + TimerNInterruptStatusRegOffset(TIMER_NUM)) != 0)
+            {
+                IOREAD32(PC20X_TIMER_BASE + TimerNEOIRegOffset(TIMER_NUM));
+                break;
+            }
+        }
+
+        /* turn LED off */
+        gpioData &= ~Gpio(LED1_GPIO_NUM);
+        IOWRITE32(gpioData, LED1_DATA_REG);
+
+        if (guardCount <= 0)
+        {
+            printf ("ERROR: Failed to detect end of timer count period within a reasonable length of time!\n");
+        }
+        else
+        {
+            printf ("LED should have been turned on for %dms (use scope to check!)\n", millisecondsForTest);
+        }
+        return 0;
+
+    default:
+        printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+        return 1;
+    }
+
+    return 0;
+}
+
+
+/*===========================================================================*/
+#if defined(OLD_STYLE_TESTS)
+/*---------------------------------------------------------------------------*/
+static unsigned long mem_write_test (unsigned char *mem_p, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+    u32     count = (PC20X_AHB_CLOCK_FREQ/1000) * testDurationMs;
+    int     guardCount = 100000000;
+    volatile u32 *m_p = (volatile u32 *)mem_p;
+    int     iStatus = icache_status ();
+
+    if (! iStatus)
+    {
+        printf ("Enabling I-Cache\n");
+        icache_enable ();
+    }
+
+
+    /* stop the timer */
+    IOWRITE32(0x0, PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+    /* load the count */
+    IOWRITE32(count, PC20X_TIMER_BASE + TimerNLoadCountRegOffset(TIMER_NUM));
+
+    /* start the timer in user defined count mode */
+    IOWRITE32((TimerEnable|TimerMode), PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+    while (--guardCount > 0)
+    {
+        if (IOREAD32(PC20X_TIMER_BASE + TimerNInterruptStatusRegOffset(TIMER_NUM)) != 0)
+        {
+            IOREAD32(PC20X_TIMER_BASE + TimerNEOIRegOffset(TIMER_NUM));
+            break;
+        }
+
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+
+        numAccesses += 64;
+    }
+
+    if (! iStatus)
+    {
+        printf ("Disabling I-Cache\n");
+        icache_disable ();
+    }
+
+    if (guardCount <= 0)
+    {
+        printf ("ERROR: Failed to detect end of timer count period within a reasonable length of time!\n");
+    }
+
+    return numAccesses;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long mem_read_test (unsigned char *mem_p, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+    u32     count = (PC20X_AHB_CLOCK_FREQ/1000) * testDurationMs;
+    int     guardCount = 100000000;
+    volatile u32 *m_p = (volatile u32 *)mem_p;
+    int     iStatus = icache_status ();
+
+    if (! iStatus)
+    {
+        printf ("Enabling I-Cache\n");
+        icache_enable ();
+    }
+
+    /* stop the timer */
+    IOWRITE32(0x0, PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+    /* load the count */
+    IOWRITE32(count, PC20X_TIMER_BASE + TimerNLoadCountRegOffset(TIMER_NUM));
+
+    /* start the timer in user defined count mode */
+    IOWRITE32((TimerEnable|TimerMode), PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+    while (--guardCount > 0)
+    {
+        if (IOREAD32(PC20X_TIMER_BASE + TimerNInterruptStatusRegOffset(TIMER_NUM)) != 0)
+        {
+            IOREAD32(PC20X_TIMER_BASE + TimerNEOIRegOffset(TIMER_NUM));
+            break;
+        }
+
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+
+        numAccesses += 64;
+    }
+
+    if (! iStatus)
+    {
+        printf ("Disabling I-Cache\n");
+        icache_disable ();
+    }
+
+    if (guardCount <= 0)
+    {
+        printf ("ERROR: Failed to detect end of timer count period within a reasonable length of time!\n");
+    }
+
+    return numAccesses;
+}
+
+/*---------------------------------------------------------------------------*/
+static void printTestResult (char *memType_p, unsigned long memAddr, int reading, int testDurationMs, unsigned long numAccesses)
+{
+    unsigned long   throughPut;
+    unsigned long   integral, decimal;
+
+    throughPut = ((((unsigned long)numAccesses)*4*8)/testDurationMs) + 5;
+
+    /* convert to 2 decimal places */
+    integral = throughPut/1000;
+    decimal = (throughPut % 1000)/10;
+
+    printf ("%-6s (0x%08lx): %10ld %s in %6d milliseconds. Throughput= %3ld.%02ld Mbps\n",
+            memType_p,
+            memAddr,
+            numAccesses,
+            (reading ? "Reads " : "Writes"),
+            testDurationMs,
+            integral,
+            decimal);
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long sdram_test (int reading, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+    u32     *mem_p = (u32 *)0x04000000;     /* spare SDRAM bank */
+
+    if (reading)
+    {
+        numAccesses = mem_read_test ((unsigned char *)mem_p, testDurationMs);
+    }
+    else
+    {
+        numAccesses = mem_write_test ((unsigned char *)mem_p, testDurationMs);
+    }
+
+    if (numAccesses <= 0)
+    {
+        printf ("SDRAM: No accesses - oops!\n");
+    }
+    else
+    {
+        printTestResult ("SDRAM", (unsigned long)mem_p, reading, testDurationMs, numAccesses);
+    }
+
+    return numAccesses;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long sram_test (int reading, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+
+    if (reading)
+    {
+        numAccesses = mem_read_test ((unsigned char *)PC20X_ONCHIP_SRAM_BASE, testDurationMs);
+    }
+    else
+    {
+        numAccesses = mem_write_test ((unsigned char *)PC20X_ONCHIP_SRAM_BASE, testDurationMs);
+    }
+
+    if (numAccesses <= 0)
+    {
+        printf ("SRAM: No accesses - oops!\n");
+    }
+    else
+    {
+        printTestResult ("SRAM", PC20X_ONCHIP_SRAM_BASE, reading, testDurationMs, numAccesses);
+    }
+
+    return numAccesses;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long flash_test (int reading, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+
+    if (reading)
+    {
+        numAccesses = mem_read_test ((unsigned char *)CFG_LOAD_ADDR, testDurationMs);
+    }
+    else
+    {
+        printf ("Flash WRITING not (yet) supported!\n");
+    }
+
+    if (numAccesses <= 0)
+    {
+        printf ("FLASH: No accesses - oops!\n");
+    }
+    else
+    {
+        printTestResult ("FLASH", CFG_LOAD_ADDR, reading, testDurationMs, numAccesses);
+    }
+
+    return numAccesses;
+}
+
+#else
+/*---------------------------------------------------------------------------*/
+static unsigned long mem2write_test (unsigned char *mem_p, int numIterations, int dummyRun)
+{
+    volatile u32    *m_p = (volatile u32 *)mem_p;
+    int             iStatus = icache_status ();
+    int             i;
+    unsigned long   startCount = 0xffffffff;
+    unsigned long   endCount;
+
+    if (! iStatus)
+    {
+        printf ("Enabling I-Cache\n");
+        icache_enable ();
+    }
+
+
+    /* stop the timer */
+    IOWRITE32(0x0, PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+    /* load the count */
+    IOWRITE32(startCount, PC20X_TIMER_BASE + TimerNLoadCountRegOffset(TIMER_NUM));
+
+    i = numIterations;
+
+    /* start the timer in user defined count mode */
+    IOWRITE32((TimerEnable|TimerMode), PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+    while (--i > 0)
+    {
+        if (! dummyRun)
+        {
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+        }
+    }
+
+    endCount = IOREAD32(PC20X_TIMER_BASE + TimerNCurrentValueRegOffset(TIMER_NUM));
+
+    if (IOREAD32(PC20X_TIMER_BASE + TimerNInterruptStatusRegOffset(TIMER_NUM)) != 0)
+    {
+        printf ("WARNING: PIT looks likes it has wrapped!\n");
+    }
+
+    if (! iStatus)
+    {
+        printf ("Disabling I-Cache\n");
+        icache_disable ();
+    }
+
+printf ("TickCount=0x%08lx\n", (startCount - endCount));
+    return (startCount - endCount);
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long mem2read_test (unsigned char *mem_p, int numIterations, int dummyRun)
+{
+    volatile u32    *m_p = (volatile u32 *)mem_p;
+    int             iStatus = icache_status ();
+    int             i;
+    unsigned long   startCount = 0xffffffff;
+    unsigned long   endCount;
+
+    if (! iStatus)
+    {
+        printf ("Enabling I-Cache\n");
+        icache_enable ();
+    }
+
+    /* stop the timer */
+    IOWRITE32(0x0, PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+    /* load the count */
+    IOWRITE32(startCount, PC20X_TIMER_BASE + TimerNLoadCountRegOffset(TIMER_NUM));
+
+    i = numIterations;
+
+    /* start the timer in user defined count mode */
+    IOWRITE32((TimerEnable|TimerMode), PC20X_TIMER_BASE + TimerNControlRegOffset(TIMER_NUM));
+
+    while (--i > 0)
+    {
+        if (! dummyRun)
+        {
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+        }
+    }
+
+    endCount = IOREAD32(PC20X_TIMER_BASE + TimerNCurrentValueRegOffset(TIMER_NUM));
+
+    if (IOREAD32(PC20X_TIMER_BASE + TimerNInterruptStatusRegOffset(TIMER_NUM)) != 0)
+    {
+        printf ("WARNING: PIT looks likes it has wrapped!\n");
+    }
+
+    if (! iStatus)
+    {
+        printf ("Disabling I-Cache\n");
+        icache_disable ();
+    }
+
+printf ("TickCount=0x%08lx\n", (startCount - endCount));
+    return (startCount - endCount);
+}
+
+/*---------------------------------------------------------------------------*/
+static void printTest2Result (char *memType_p, unsigned long memAddr, int reading, int numIterations, unsigned long tickCount)
+{
+    unsigned long   throughPut;
+    unsigned long   integral, decimal;
+
+    throughPut = (((((unsigned long)numIterations)*64*8*4) / (tickCount/1000)) * (PC20X_AHB_CLOCK_FREQ/1000)) + 5;
+    throughPut /= 1000;
+
+    /* convert to 2 decimal places */
+    integral = throughPut/1000;
+    decimal = (throughPut % 1000)/10;
+
+    printf ("%-6s (0x%08lx): %10ld %s in %6ld ms. Throughput= %3ld.%02ld Mbps\n",
+            memType_p,
+            memAddr,
+            ((unsigned long)numIterations*64),
+            (reading ? "Reads " : "Writes"),
+            tickCount/(PC20X_AHB_CLOCK_FREQ/1000),
+            integral,
+            decimal);
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long sdram2test (int reading, int numIterations)
+{
+    unsigned long     tickCount = 0;
+    unsigned long     tickCount2 = 0;
+    u32     *mem_p = (u32 *)0x04000000;     /* spare SDRAM bank */
+
+    if (reading)
+    {
+        tickCount = mem2read_test ((unsigned char *)mem_p, numIterations, 0);
+        tickCount2 = mem2read_test ((unsigned char *)mem_p, numIterations, 1);
+    }
+    else
+    {
+        tickCount = mem2write_test ((unsigned char *)mem_p, numIterations, 0);
+        tickCount2 = mem2write_test ((unsigned char *)mem_p, numIterations, 1);
+    }
+
+    if (tickCount <= 0)
+    {
+        printf ("SDRAM: No accesses - oops!\n");
+    }
+    else
+    {
+        printTest2Result ("SDRAM", (unsigned long)mem_p, reading, numIterations, (tickCount - tickCount2));
+    }
+
+    return tickCount;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long sram2test (int reading, int numIterations)
+{
+    unsigned long     tickCount = 0;
+    unsigned long     tickCount2 = 0;
+
+    if (reading)
+    {
+        tickCount = mem2read_test ((unsigned char *)PC20X_ONCHIP_SRAM_BASE, numIterations, 0);
+        tickCount2 = mem2read_test ((unsigned char *)PC20X_ONCHIP_SRAM_BASE, numIterations, 1);
+    }
+    else
+    {
+        tickCount = mem2write_test ((unsigned char *)PC20X_ONCHIP_SRAM_BASE, numIterations, 0);
+        tickCount2 = mem2write_test ((unsigned char *)PC20X_ONCHIP_SRAM_BASE, numIterations, 1);
+    }
+
+    if (tickCount <= 0)
+    {
+        printf ("SRAM: No accesses - oops!\n");
+    }
+    else
+    {
+        printTest2Result ("SRAM", (unsigned long)PC20X_ONCHIP_SRAM_BASE, reading, numIterations, (tickCount - tickCount2));
+    }
+
+    return tickCount;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long flash2test (int reading, int numIterations)
+{
+    unsigned long     tickCount = 0;
+    unsigned long     tickCount2 = 0;
+
+    if (reading)
+    {
+        tickCount = mem2read_test ((unsigned char *)CFG_LOAD_ADDR, numIterations, 0);
+        tickCount2 = mem2read_test ((unsigned char *)CFG_LOAD_ADDR, numIterations, 1);
+    }
+    else
+    {
+        printf ("Flash WRITING not (yet) supported!\n");
+    }
+
+    if (tickCount <= 0)
+    {
+        printf ("FLASH: No accesses - oops!\n");
+    }
+    else
+    {
+        printTest2Result ("FLASH", (unsigned long)CFG_LOAD_ADDR, reading, numIterations, (tickCount - tickCount2));
+    }
+
+    return tickCount;
+}
+
+#endif  /* defined(OLD_STYLE_TESTS) */
+
+
+/*---------------------------------------------------------------------------*/
+/* run the memcal command.
+ * This runs a number of read or write access as fast as it can in a set time period.
+ */
+int do_memcal (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+#if defined(OLD_STYLE_TESTS)
+    u32             testDurationMs = 2000;
+#endif  /* defined(OLD_STYLE_TESTS) */
+    int             argsOK = 1;
+    int             reading = 1;
+    MemType         memType = MT_SDRAM;
+    int             result = 0;
+
+    switch (argc)
+    {
+    case 2:
+        if (strcmp (argv[1], "full") == 0)
+        {
+            memType = MT_FULL_TEST;
+        }
+        else
+        {
+            argsOK = 0;
+        }
+        break;
+
+    case 3:
+        if (strcmp (argv[1], "sdram") == 0)
+        {
+            memType = MT_SDRAM;
+        }
+        else if (strcmp (argv[1], "sram") == 0)
+        {
+            memType = MT_SRAM;
+        }
+        else if (strcmp (argv[1], "flash") == 0)
+        {
+            memType = MT_FLASH;
+        }
+        else
+        {
+            printf ("Bad memory type\n");
+            argsOK = 0;
+        }
+
+        if (strcmp (argv[2], "r") == 0)
+        {
+            reading = 1;
+        }
+        else if (strcmp (argv[2], "w") == 0)
+        {
+            reading = 0;
+        }
+        else
+        {
+            printf ("Bad access type (r or w)\n");
+            argsOK = 0;
+        }
+        break;
+
+    default:
+        printf ("Bad number of arguments\n");
+        argsOK = 0;
+        break;
+    }
+
+
+    if (argsOK)
+    {
+        switch (memType)
+        {
+            case MT_SDRAM:
+#if defined(OLD_STYLE_TESTS)
+                sdram_test (reading, testDurationMs);
+#else
+                sdram2test (reading, NUM_TEST_ITERATIONS);
+#endif  /* defined(OLD_STYLE_TESTS) */
+                break;
+            case MT_SRAM:
+#if defined(OLD_STYLE_TESTS)
+                sram_test (reading, testDurationMs);
+#else
+                sram2test (reading, NUM_TEST_ITERATIONS);
+#endif  /* defined(OLD_STYLE_TESTS) */
+                break;
+            case MT_FLASH:
+#if defined(OLD_STYLE_TESTS)
+                flash_test (reading, testDurationMs);
+#else
+                flash2test (reading, NUM_TEST_ITERATIONS);
+#endif  /* defined(OLD_STYLE_TESTS) */
+                break;
+            case MT_FULL_TEST:
+                {
+                    int     iStatus = icache_status ();
+
+                    if (! iStatus)
+                    {
+                        printf ("Enabling I-Cache\n");
+                        icache_enable ();
+                    }
+
+#if defined(OLD_STYLE_TESTS)
+                    sdram_test (1, testDurationMs);
+                    sdram_test (0, testDurationMs);
+                    sram_test (1, testDurationMs);
+                    sram_test (0, testDurationMs);
+                    flash_test (1, testDurationMs);
+#else
+                    sdram2test (1, NUM_TEST_ITERATIONS);
+                    sdram2test (0, NUM_TEST_ITERATIONS);
+                    sram2test (1, NUM_TEST_ITERATIONS);
+                    sram2test (0, NUM_TEST_ITERATIONS);
+                    flash2test (1, NUM_TEST_ITERATIONS);
+#endif  /* defined(OLD_STYLE_TESTS) */
+
+                    if (! iStatus)
+                    {
+                        printf ("Disabling I-Cache\n");
+                        icache_disable ();
+                    }
+                }
+                break;
+            default:
+                printf ("Bad memory type - coding error!\n");
+                break;
+        }
+    }
+    else
+    {
+        result = 1;
+        printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+    }
+
+
+    return result;
+}
+
+/*===========================================================================*/
+static void reportHwConfig (void)
+{
+    unsigned long i;
+    unsigned long c1;
+    int     armMode;
+
+    asm ("mrs %0,cpsr":"=r" (i));
+    armMode = i & 0x1f;
+    printf ("ARM CPSR=0x%08lx (IRQ=%s, FIQ=%s, Thumb=%s, Mode=%s)\n",
+            i,
+            (i & 0x0080) ? "DISABLED" : "ENABLED",
+            (i & 0x0040) ? "DISABLED" : "ENABLED",
+            (i & 0x0020) ? "ENABLED"  : "DISABLED",
+            (armMode == 0x13) ? "Supervisor"
+                              : (armMode == 0x10) ? "User"
+                                                  : (armMode == 0x1f) ? "System"
+                                                                      : (armMode == 0x11) ? "FIQ"
+                                                                                          : (armMode == 0x12) ? "IRQ"
+                                                                                                              : "??????"
+           );
+
+    /* read c1 */
+    asm ("mrc p15, 0, %0, c1, c0, 0":"=r" (c1));
+    printf ("ARM CP15: Control (1)=0x%08lx  (I-Cache=%s, D-Cache=%s, MMU=%s)\n",
+            c1,
+            (c1 & 0x1000) ? "ON" : "OFF",
+            (c1 & 0x0004) ? "ON" : "OFF",
+            (c1 & 0x0001) ? "ON" : "OFF"
+           );
+}
+
+/*---------------------------------------------------------------------------*/
+static void reportMemArb (void)
+{
+    int                 i;
+    int                 slotOff;
+    unsigned short      value;
+    unsigned short      valid;
+    volatile unsigned short *armReg_p = (volatile unsigned short *)PC20X_MEM_IF_BASE;
+    volatile unsigned short *addr_p;
+
+    /* SDRAM */
+    addr_p = armReg_p + (MemifSdramArbValidGroupsConfigRegOffset/2);
+    valid = IOREAD16(addr_p);
+
+    for (i=0; i<16; i++)
+    {
+        if (valid & (1 << (i/2)))
+        {
+            slotOff = ((i & 1) << 1);
+
+            addr_p = armReg_p + (MemifSdramArbGroup0SlotAConfigRegOffset/2) + i;
+            value = IOREAD16(addr_p);
+
+            printf ("SDRAM_arb_group_%d_Slot_%d = %s,%s,%s,%dacc\n",
+                                        (i/2), slotOff,
+                                        (value & 0x0001) ? "pico" : "AHB ",
+                                        (value & 0x0002) ? "Opp" : "Det",
+                                        (value & 0x0004) ? "W" : "R",
+                                        (((value & 0x0018) >> 3) + 1)*8
+                   );
+            printf ("SDRAM_arb_group_%d_Slot_%d = %s,%s,%s,%dacc\n",
+                                        (i/2), slotOff + 1,
+                                        (value & 0x0100) ? "pico" : "AHB ",
+                                        (value & 0x0200) ? "Opp" : "Det",
+                                        (value & 0x0400) ? "W" : "R",
+                                        (((value & 0x1800) >> 11) + 1)*8
+                   );
+        }
+    }
+    printf ("\n");
+
+
+    /* SRAM */
+    addr_p = armReg_p + (MemifSramArbValidSlotsConfigRegOffset/2);
+    valid = IOREAD16(addr_p);
+
+    for (i=0; i<3; i++)
+    {
+        slotOff = i << 1;
+
+        addr_p = armReg_p + (MemifSramArbSlotAConfigRegOffset/2) + i;
+        value = IOREAD16(addr_p);
+
+        if (valid & (1 << (2*i)))
+        {
+            printf ("SRAM_arb_Slot_%d = %s,%s,%s,%dacc,%s\n",
+                                        slotOff,
+                                        (value & 0x0001) ? "pico" : "AHB ",
+                                        (value & 0x0002) ? "Opp" : "Det",
+                                        (value & 0x0004) ? "W" : "R",
+                                        (1 << ((value & 0x0018) >> 3)),
+                                        ((value & 0x0001) ? ((value & 0x0020) ? "Buff1" : "Buff0")
+                                                        : ((value & 0x0002) ? ((value & 0x0020) ? "Buff1" : "Buff0")
+                                                                            : "-"
+                                                            )
+                                        )
+                   );
+        }
+
+        if (valid & (1 << (2*i + 1)))
+        {
+            printf ("SRAM_arb_Slot_%d = %s,%s,%s,%dacc,%s\n",
+                                        slotOff + 1,
+                                        (value & 0x0100) ? "pico" : "AHB ",
+                                        (value & 0x0200) ? "Opp" : "Det",
+                                        (value & 0x0400) ? "W" : "R",
+                                        (1 << ((value & 0x1800) >> 3)),
+                                        ((value & 0x0100) ? ((value & 0x2000) ? "Buff1" : "Buff0")
+                                                        : ((value & 0x0200) ? ((value & 0x2000) ? "Buff1" : "Buff0")
+                                                                            : "-"
+                                                            )
+                                        )
+                   );
+        }
+    }
+    printf ("\n");
+}
+
+
+/*---------------------------------------------------------------------------*/
+static void reportSdramCfg (void)
+{
+    volatile unsigned short *armReg_p = (volatile unsigned short *)PC20X_MEM_IF_BASE;
+    volatile unsigned short *addr_p;
+
+    /* SDRAM */
+    addr_p = armReg_p + (DLL0SlaveAdjustRegOffset/2);
+    printf ("SDRAM DLL Slave Adjusts: 0x%04x  0x%04x  0x%04x  0x%04x\n",
+            IOREAD16(addr_p),
+            IOREAD16((addr_p + 3)),
+            IOREAD16((addr_p + 6)),
+            IOREAD16((addr_p + 9)));
+
+    addr_p = armReg_p + (MemifSdramSetupRegOffset/2);
+    printf ("SDRAM Setup: 0x%04x\n", IOREAD16(addr_p));
+
+    addr_p = armReg_p + (MemifSdramRefreshRateRegOffset/2);
+    printf ("SDRAM Refresh Rate: 0x%04x\n", IOREAD16(addr_p));
+
+    addr_p = armReg_p + (MemifSdramMrsRegOffset/2);
+    printf ("SDRAM Mode: 0x%04x\n", IOREAD16(addr_p));
+
+    addr_p = armReg_p + (MemifSdramErsRegOffset/2);
+    printf ("SDRAM EMRS: 0x%04x\n", IOREAD16(addr_p));
+
+    printf ("\n");
+}
+
+/*---------------------------------------------------------------------------*/
+/* run the memcfg command.
+ */
+int do_memcfg (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int     result = 0;
+    switch (argc)
+    {
+    case 1:
+/* for one-off test, changed CAS strobe - gave 1% increase in SDRAM reads (no affact on writes) */
+/* *((volatile u16 *)(PC20X_MEM_IF_BASE + MemifSdramMrsRegOffset)) = 0x443;*/
+        reportHwConfig ();
+        reportMemArb ();
+        reportSdramCfg ();
+        break;
+
+    default:
+        printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+        result = 1;
+        break;
+    }
+
+    return result;
+}
+
+
+/*===========================================================================*/
+#define SDRAM_CFG_DATA_SIZE     17
+typedef unsigned short SDRAM_CFG_DATA [SDRAM_CFG_DATA_SIZE];
+
+#define SRAM_CFG_DATA_SIZE      4
+typedef unsigned short SRAM_CFG_DATA [SRAM_CFG_DATA_SIZE];
+
+
+#define MAX_SDRAM_CFGS          5
+SDRAM_CFG_DATA  sdramCfgData [MAX_SDRAM_CFGS] =
+{   /* just ARM access */
+    {0x0000, 0x0000, 0x0404, 0x0404, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x0003
+    },
+
+    /* ARM + pico equal access */
+    {0x0404, 0x0404, 0x0505, 0x0505, 0x0000, 0x0000, 0x0101, 0x0101,
+     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x000f
+    },
+
+    /* ARM (det) + pico (opp) access */
+    {0x0404, 0x0404, 0x0707, 0x0707, 0x0000, 0x0000, 0x0303, 0x0303,
+     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x000f
+    },
+
+    /* ARM (opp) + pico (opp) access */
+    {0x0606, 0x0606, 0x0707, 0x0707, 0x0202, 0x0202, 0x0303, 0x0303,
+     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x000f
+    },
+
+    /* just ARM - but using all groups */
+    {0x0000, 0x0000, 0x0404, 0x0404, 0x0000, 0x0000, 0x0404, 0x0404,
+     0x0000, 0x0000, 0x0404, 0x0404, 0x0000, 0x0000, 0x0404, 0x0404,
+     0x00ff
+    },
+};
+
+#define MAX_SRAM_CFGS           3
+SRAM_CFG_DATA   sramCfgData [MAX_SRAM_CFGS] =
+{   /* just ARM access */
+    {0x0004, 0x0000, 0x0000,
+     0x0003
+    },
+
+    /* ARM + pico equal access */
+    {0x0504, 0x0025, 0x2101,
+     0x003f
+    },
+
+    /* ARM (det) + pico (opp) access */
+    {0x0704, 0x0027, 0x2303,
+     0x003f
+    }
+};
+
+
+static void sdramConfig (int sdramCfg)
+{
+    int                 i;
+    volatile unsigned short *addr_p = ((volatile unsigned short *)PC20X_MEM_IF_BASE) + 0x20;
+    SDRAM_CFG_DATA      *cfgData_p  = &sdramCfgData [sdramCfg];
+
+    for (i=0; i<SDRAM_CFG_DATA_SIZE; i++)
+    {
+        IOWRITE16((*cfgData_p) [i], addr_p);
+
+        addr_p++;
+    }
+
+    /* make it so */
+    addr_p = ((volatile unsigned short *)PC20X_MEM_IF_BASE) + 0x4f;
+    IOWRITE16(0x0001, addr_p);
+
+    while ((IOREAD16(addr_p) & 0x0001) == 0x0001)
+    {
+    }
+}
+
+/*-----------------------------------------------------------------------*/
+static void sramConfig (int sramCfg)
+{
+    int                 i;
+    volatile unsigned short *addr_p = ((volatile unsigned short *)PC20X_MEM_IF_BASE) + 0x40;
+    SRAM_CFG_DATA       *cfgData_p  = &sramCfgData [sramCfg];
+
+    for (i=0; i<SRAM_CFG_DATA_SIZE; i++)
+    {
+        IOWRITE16((*cfgData_p) [i], addr_p);
+
+        addr_p++;
+    }
+
+    /* make it so */
+    addr_p = ((volatile unsigned short *)PC20X_MEM_IF_BASE) + 0x4f;
+    IOWRITE16(0x0002, addr_p);
+
+    while ((IOREAD16(addr_p) & 0x0002) == 0x0002)
+    {
+    }
+}
+
+/*---------------------------------------------------------------------------*/
+/* run the memarb command.
+ */
+int do_memarb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int     result = 0;
+    int     i;
+    int     len;
+    int     argsOK = 1;
+    int     sdramCfg = -1;
+    int     sramCfg = -1;
+
+    switch (argc)
+    {
+    case 1:
+        reportHwConfig ();
+        reportMemArb ();
+        reportSdramCfg ();
+        break;
+
+    default:
+        /*-----------------------------------------------------------------------*/
+        /* input parameter checking ... */
+        for (i=1; i< argc; i++)
+        {
+            if (strncmp (argv[i], "sdram", 5) == 0)
+            {
+                len = strlen (argv[i]);
+                if (len != 6)
+                {
+                    argsOK = 0;
+                }
+                else
+                {
+                    char    ch = argv[i][5];
+                    if ((ch < '0') || (ch > '9'))
+                    {
+                        argsOK = 0;
+                    }
+                    else
+                    {
+                        sdramCfg = ch - '0';
+                        if (sdramCfg >= MAX_SDRAM_CFGS)
+                        {
+                            argsOK = 0;
+                        }
+                    }
+                }
+            }
+            else if (strncmp (argv[i], "sram", 4) == 0)
+            {
+                len = strlen (argv[i]);
+                if (len != 5)
+                {
+                    argsOK = 0;
+                }
+                else
+                {
+                    char    ch = argv[i][4];
+                    if ((ch < '0') || (ch > '9'))
+                    {
+                        argsOK = 0;
+                    }
+                    else
+                    {
+                        sramCfg = ch - '0';
+                        if (sramCfg >= MAX_SRAM_CFGS)
+                        {
+                            argsOK = 0;
+                        }
+                    }
+                }
+            }
+            else
+            {
+                argsOK = 0;
+            }
+        }
+
+        if (argsOK)
+        {
+            if (sdramCfg != -1)
+            {
+                sdramConfig (sdramCfg);
+            }
+
+            if (sramCfg != -1)
+            {
+                sramConfig (sramCfg);
+            }
+        }
+        else
+        {
+            printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+            result = 1;
+        }
+        break;
+    }
+
+    return result;
+}
+
+
+/*---------------------------------------------------------------------------*/
+/* run the set_led command.
+ */
+int do_set_led (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int     result = 1;
+
+    if (argc == 2)
+    {
+        if (strcmp (argv[1], "green") == 0)
+        {
+            u32  gpioData;
+
+            /* set GPIO line to output for LED */
+            gpioData = IOREAD32(LED2_DIR_REG);
+            gpioData |= Gpio(LED2_GPIO_NUM);
+            IOWRITE32(gpioData, LED2_DIR_REG);
+
+            /* ensure LED is on/green */
+            gpioData = IOREAD32(LED2_DATA_REG);
+            gpioData |= Gpio(LED2_GPIO_NUM);
+            IOWRITE32(gpioData, LED2_DATA_REG);
+
+            result = 0;
+        }
+        else if (strcmp (argv[1], "red") == 0)
+        {
+            u32  gpioData;
+
+            /* set GPIO line to output for LED */
+            gpioData = IOREAD32(LED2_DIR_REG);
+            gpioData |= Gpio(LED2_GPIO_NUM);
+            IOWRITE32(gpioData, LED2_DIR_REG);
+
+            /* ensure LED is off/red */
+            gpioData = IOREAD32(LED2_DATA_REG);
+            gpioData &= ~Gpio(LED2_GPIO_NUM);
+            IOWRITE32(gpioData, LED2_DATA_REG);
+
+            result = 0;
+        }
+    }
+
+    if (result)
+    {
+        printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+    }
+
+    return result;
+}
+
+
+#ifdef CONFIG_BOOTCOUNT_LIMIT
+
+#define SRAM_BOOT_VARS_ADDRESS 0x1001ffc0
+
+void bootcount_init ()
+{
+	volatile ulong *save_addr =
+		(volatile ulong *)(SRAM_BOOT_VARS_ADDRESS);
+	int i;
+
+	if (save_addr[15] != BOOTCOUNT_MAGIC)
+	{
+		for(i=0; i<15; i++)
+			save_addr[i] = 0;
+		save_addr[15] = BOOTCOUNT_MAGIC;
+	}
+}
+
+void bootcount_store (ulong a)
+{
+	volatile ulong *save_addr =
+		(volatile ulong *)(SRAM_BOOT_VARS_ADDRESS);
+
+	bootcount_init();  // Initialise boot variables if no BOOTCOUNT_MAGIC
+	save_addr[14] = a;
+}
+
+ulong bootcount_load (void)
+{
+	volatile ulong *save_addr =
+		(volatile ulong *)(SRAM_BOOT_VARS_ADDRESS);
+
+	if (save_addr[15] != BOOTCOUNT_MAGIC)
+		return 0;
+	else
+		return save_addr[14];
+}
+
+#endif /* CONFIG_BOOTCOUNT_LIMIT */
+
+
+/*===========================================================================*/
+
+U_BOOT_CMD(
+    timcal,   2,   1,     do_timcal,
+    "timcal  - calibrate timing (via LED and using scope)\n",
+    "  args: <N> - number of milliseconds to drive LED high (beware arithmetic rounding issues!)"
+);
+
+
+U_BOOT_CMD(
+    memcal,   3,   1,     do_memcal,
+    "memcal  - calibrate memory read or write timing (assumes timing calibrated successfully - see timcal)\n",
+    "  args: [sdram | sram | flash] [r | w] - type of memory + read or write"
+);
+
+
+U_BOOT_CMD(
+    memcfg,   1,   1,     do_memcfg,
+    "memcfg  - report ARM/PC202 configuration affecting memory access speed\n",
+    ""
+);
+
+
+U_BOOT_CMD(
+    memarb,   3,   1,     do_memarb,
+    "memarb  - report/change SDRAM/SRAM arbitration scheme\n",
+    "  args: [sdram<n>] [sram<m>] where:-\n"
+    "    sdram<n> configures SDRAM config number n\n"
+    "          0 => just ARM access\n"
+    "          1 => ARM + pico equal access\n"
+    "          2 => ARM (deterministic) + pico (opportunistic) access\n"
+    "          3 => ARM (opportunistic) + pico (opportunistic) access\n"
+    "          4 => just ARM access - all 8 groups\n"
+    "    sram<m> configures SRAM config number m\n"
+    "          0 => just ARM access\n"
+    "          1 => ARM + pico equal access\n"
+    "          2 => ARM (deterministic) + pico (opportunistic) access\n"
+);
+
+U_BOOT_CMD(
+    set_led,   2,   1,     do_set_led,
+    "set_led - change colour of Sys/Pwr LED\n",
+    "  args: [red | green]"
+);
+
+#endif	/* CFG_CMD_CACHE */
diff -Naur pico_1.3.4/board/ipaccess/ip202ff/config.mk ipa_1.3.4/board/ipaccess/ip202ff/config.mk
--- pico_1.3.4/board/ipaccess/ip202ff/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip202ff/config.mk	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,33 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file config.mk
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+TEXT_BASE = 0x05000000
+
+ifdef BSP_ARCH
+ifeq ($(CPE20X_2BANKS), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_PC20X_2_DDR_RAM_BANKS
+endif
+endif
+
+ifdef BSP_DIR
+include $(BSP_DIR)/config
+PLATFORM_CPPFLAGS += -DPICOCHIP_PLATFORM_VERSION=\"$(RELEASE_VERSION)\"
+endif
+
+ifeq ($(CPE20X_RUN_FROM_RAM), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_RUN_FROM_RAM
+endif
diff -Naur pico_1.3.4/board/ipaccess/ip202ff/cpe20x.c ipa_1.3.4/board/ipaccess/ip202ff/cpe20x.c
--- pico_1.3.4/board/ipaccess/ip202ff/cpe20x.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip202ff/cpe20x.c	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,280 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file cpe20x.c
+* \brief Various useful functions for use on a CPE20X Platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/arch/pc20x.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/gpio.h>
+
+/* Constants --------------------------------------------------------------- */
+DECLARE_GLOBAL_DATA_PTR;
+
+/* Macros ------------------------------------------------------------------ */
+#define PA_TIMECOUNT 32
+#define PROCIFCONFIGREADREGOFFSET   0x78
+#define PROCIFCONFIGWRITEREGOFFSET  0x7C
+#define PA_CONFIG_WRITE             0x00010000
+#define PA_CONFIG_READ              0x00020000
+#define PA_CONFIG_ADDR              0x00040000
+#define PA_CONFIG_AEID              0x00080000
+#define PA_CONFIG_VALID             0x00010000
+#define PA_CONFIG_FAIL              0x00020000
+#define PA_CONFIG_TIMEOUTOCCURED    0x00040000
+#define PA_AEID_PROCINT2            0x0048
+#define PA_PROCINT2_DEVICEID        0x0030
+
+#define PA_DEVICE_ID_MASK           0xFFFF
+#define PC202_DEVICE_ID             0x00000010
+#define PC203_DEVICE_ID             0x00000011
+#define PC205_DEVICE_ID             0x00000012
+
+/* FPGA Device ID register */
+#define FPGA_DID_REG                (0)
+
+/* The device ID reg changed between v1 and v2 */
+#define V1_FPGA_DID_BOARD_TYPE_SHIFT   (4)
+#define V1_FPGA_DID_BOARD_TYPE_MASK    (0xff << V1_FPGA_DID_BOARD_TYPE_SHIFT)
+
+#define V2_FPGA_DID_BOARD_TYPE_SHIFT   (8)
+#define V2_FPGA_DID_BOARD_TYPE_MASK    (0xff << V2_FPGA_DID_BOARD_TYPE_SHIFT)
+#define V2_FPGA_DID_PCB_BUILD_SHIFT    (4)
+#define V2_FPGA_DID_PCB_BUILD_MASK     (0x0f << V2_FPGA_DID_PCB_BUILD_SHIFT)
+
+#define FPGA_DID_DEVICE_ID_SHIFT    (0)
+#define FPGA_DID_DEVICE_ID_MASK     (0x0f << FPGA_DID_DEVICE_ID_SHIFT)
+
+/* Board types: */
+#define BOARD_TYPE_PC7205           (6)
+#define BOARD_TYPE_HDP203           (7)
+
+/* PCB Builds: TODO validate */
+#define PCB_BUILD_PC72052_I10_REVB  (0)
+
+/* Device IDs: */
+#define DID_RC_FPGA                 (1)
+#define DID_AD_FPGA                 (2)
+
+/* FPGA version register */
+#define FPGA_VERSION_REG            (1)
+
+#define FPGA_VERS_CODE_REL_SHIFT    (8)
+#define FPGA_VERS_CODE_REL_MASK     (0xff << FPGA_VERS_CODE_REL_SHIFT)
+#define FPGA_VERS_CODE_REV_SHIFT    (0)
+#define FPGA_VERS_CODE_REV_MASK     (0xff << FPGA_VERS_CODE_REV_SHIFT)
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ *
+ * Start timer #0 in free running mode
+ *
+ */
+static void pc20xTimer0Start(void);
+
+/*!
+ *
+ *  Read proc-if configuration space
+ *
+ * \param procAEID AEID of block in picoArray being accessed
+ * \param procConfigAddress Address in the picoArray being accessed
+ * \return Data read from AEID & Addr + state of read
+ *         bit 16 = valid
+ *         bit 17 = fail from picoArray
+ *         bit 18 = timeout occured
+ */
+static unsigned int procConfigRead (unsigned int procAEID, unsigned int procConfigAddress);
+
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
+        gd->bd->bi_arch_number = MACH_TYPE_PC72052_I10_REVB;
+	gd->flags = 0;
+
+	icache_enable ();
+
+        pc20xTimer0Start();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+    unsigned int deviceType;
+
+    puts("Build: picoChip "PICOCHIP_PLATFORM" \n");
+
+    /* What device are we running on ? */
+    puts("Device: ");
+
+    deviceType = procConfigRead (PA_AEID_PROCINT2, PA_PROCINT2_DEVICEID);
+    if ((deviceType & PA_CONFIG_VALID) == PA_CONFIG_VALID)
+    {
+        /* We have a successful read... */
+        deviceType = deviceType & PA_DEVICE_ID_MASK;
+        switch (deviceType)
+        {
+            case PC202_DEVICE_ID:
+            {
+                puts("PC202\n");
+                break;
+            }
+            case PC203_DEVICE_ID:
+            {
+                puts("PC203\n");
+                break;
+            }
+            case PC205_DEVICE_ID:
+            {
+                puts("PC205\n");
+                break;
+            }
+            default:
+            {
+                puts("Unknown !\n");
+            }
+        }
+    }
+    else
+    {
+        /* Didn't have a successful read */
+        puts("Failed to read the device id !\n");
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * misc_init_r()
+ *
+ * Purpose: Not used right now, function template left here as a place holder
+ *
+ ****************************************************************************/
+int misc_init_r (void)
+{
+    /* Not used right now, function template left here as a place holder */
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * dram_init()
+ *
+ * Purpose: Initialize the DDR-RAM info in the board data structure
+ *
+ ****************************************************************************/
+int dram_init (void)
+{
+
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+    gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+    gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+    gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
+    gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
+    gd->bd->bi_dram[3].start = PHYS_SDRAM_4;
+    gd->bd->bi_dram[3].size = PHYS_SDRAM_4_SIZE;
+
+#else   /* We want a 2 DDR Bank setup then */
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+    gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+    gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+
+#endif
+
+    return 0;
+}
+
+static void pc20xTimer0Start(void)
+{
+    /* Make sure timer #0 is disabled */
+    *(volatile unsigned int *)(CFG_TIMERBASE + TimerNControlRegOffset(0)) = 0;
+
+    /* Initialise the timer #0 to all 1's.  We do this  because we want to run
+       the timer in free running mode. */
+    *(volatile unsigned int *)(CFG_TIMERBASE + TimerNLoadCountRegOffset(0)) =
+                               0xFFFFFFFF;
+
+    /* Start timer #0 in free running mode */
+    *(volatile unsigned int *)(CFG_TIMERBASE + TimerNControlRegOffset(0)) =
+                              (TimerInterruptMask | TimerEnable);
+}
+
+static unsigned int procConfigRead ( unsigned int procAEID, unsigned int procConfigAddress)
+{
+    unsigned int failed = 0;
+    unsigned int valid  = 0;
+    unsigned int timeout = PA_TIMECOUNT;
+    unsigned int procReadData = 0;
+
+    /* Write the AEID */
+    *(volatile unsigned int *)(PC20X_SLAVE_PROCIF_BASE + PROCIFCONFIGWRITEREGOFFSET) = (PA_CONFIG_AEID | procAEID);
+
+    /* Write the address being accessed */
+    *(volatile unsigned int *)(PC20X_SLAVE_PROCIF_BASE + PROCIFCONFIGWRITEREGOFFSET) = (PA_CONFIG_ADDR | procConfigAddress);
+
+    /* Write request for a read access */
+    *(volatile unsigned int *)(PC20X_SLAVE_PROCIF_BASE + PROCIFCONFIGWRITEREGOFFSET) = PA_CONFIG_READ;
+
+    /* Perform reads */
+
+    while( timeout != 0 && failed != 1 && valid != 1)
+    {
+        /* Read the procif */
+        procReadData =  *(volatile unsigned int *)(PC20X_SLAVE_PROCIF_BASE + PROCIFCONFIGREADREGOFFSET);
+
+        /* if valid bit set then set flag */
+        if(procReadData & PA_CONFIG_VALID)
+        {
+            valid = 1;
+        }
+
+        /* if fail bit set then set flag */
+        if(procReadData & PA_CONFIG_FAIL)
+        {
+            failed = 1;
+        }
+
+        /* increment timeout count */
+        timeout--;
+    }
+
+    if(timeout == 0)
+    {
+        procReadData = procReadData | PA_CONFIG_TIMEOUTOCCURED;
+    }
+
+    return procReadData;
+}
+
diff -Naur pico_1.3.4/board/ipaccess/ip202ff/lowlevel_init.S ipa_1.3.4/board/ipaccess/ip202ff/lowlevel_init.S
--- pico_1.3.4/board/ipaccess/ip202ff/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip202ff/lowlevel_init.S	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,349 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file lowlevel_init.S
+* \brief Various low level setup functions.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#include <config.h>
+#include <asm/arch/pc20x.h>
+#include <asm/arch/memif.h>
+#include <asm/arch/ebi.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/rap.h>
+#include <asm/arch/procif.h>
+
+/*****************************************************************************
+ *
+ * lowlevel_init
+ *
+ * Description: Perform some low level PC20x initialisation
+ *
+ *****************************************************************************/
+
+ .global lowlevel_init
+
+ lowlevel_init:
+
+        /* Preserve link register across call */
+        mov r11,lr
+
+#ifdef CONFIG_PC20X_SIMULATION
+        bl      register_initialisation
+#endif
+
+        /* Extinguish LEDS controlled by the ARM gpio */
+        bl      extinguishArmLeds
+
+        /* Setup the ebi memory interface (Flash Memory) */
+        bl      ebi_init
+
+        /* Setup the memory interface (DDR2 Memory) */
+        bl      memif_init
+
+        /* Restore link register */
+        mov     lr, r11
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * ebi_init
+ *
+ * Description: Initialise the External Bus Interface
+ *
+ *****************************************************************************/
+
+ebi_init:
+        ldr     r2, =PC20X_EBI_BASE
+        ldr     r3, =StaticMemTimSet0Value
+        str     r3, [r2, #StaticMemTimSet0RegOffset]
+
+        /* Disable all three 'Write Protect' outputs from the EBI */
+        ldr     r3, [r2, #StaticMemControlRegOffset]
+        orr     r3, r3, #WriteProtectAllDisable
+        str     r3, [r2, #StaticMemControlRegOffset]
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * memif_init
+ *
+ * Description: Initialise the Memory Controller
+ *
+ * Note:
+ * Before using SDRAM, we must wait 200us for it to initialise, accesses
+ * will be held off until the initialisation process is complete.
+ *
+ *****************************************************************************/
+
+memif_init:
+
+/*****************************************************************************
+ Reset the MEMIF before continuing
+*****************************************************************************/
+        ldr     r0, =PC20X_PROCIF_BASE
+        ldr     r1, =ProcifIntGpioRegOffset
+        ldr     r2, =ProcifGpioMemifSofResetMask
+        orr     r0, r0, r1
+
+        ldr     r1, [r0]
+        orr     r1, r1, r2
+        str     r1, [r0]
+
+waitForMemIfResetToClear:
+        ldr     r1, [r0]
+        ands    r1, r1, r2
+        bne     waitForMemIfResetToClear
+
+/*****************************************************************************
+ Setup MEMIF base address
+*****************************************************************************/
+
+        ldr     r2, =PC20X_MEM_IF_BASE
+
+/*****************************************************************************
+ DLL Configuration
+*****************************************************************************/
+
+/* DLL #0 */
+        ldr     r3, =DLL0SlaveAdjustValue
+        ldr     r4, =DLL0SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* DLL #1 */
+        ldr     r3, =DLL1SlaveAdjustValue
+        ldr     r4, =DLL1SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* DLL #2 */
+        ldr     r3, =DLL2SlaveAdjustValue
+        ldr     r4, =DLL2SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* DLL #3 */
+        ldr     r3, =DLL3SlaveAdjustValue
+        ldr     r4, =DLL3SlaveAdjustRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* Initiate a DLL update */
+        ldr     r3, =DLLConfigUpdate
+        ldr     r4, =DLLConfigUpdateRegOffset
+        orr     r4, r4, r2
+        strh    r3, [r4]
+
+/* Wait until the DLL update has completed */
+
+waitForDLLUpdate:
+        ldrh    r3, [r4]
+        tst     r3, #DLLConfigUpdateInProgress
+        bne     waitForDLLUpdate
+
+/*****************************************************************************
+ SDRAM Arbitration
+*****************************************************************************/
+
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+        mov     r3, #0x0000
+        strh    r3, [r2, #MemifSdramArbGroup0SlotAConfigRegOffset]
+        strh    r3, [r2, #MemifSdramArbGroup0SlotBConfigRegOffset]
+
+        mov     r3, #0x0400
+        orr     r3, r3, #0x0004
+        strh    r3, [r2, #MemifSdramArbGroup1SlotAConfigRegOffset]
+        strh    r3, [r2, #MemifSdramArbGroup1SlotBConfigRegOffset]
+
+        mov     r3, #0x0003
+        strh    r3, [r2, #MemifSdramArbValidGroupsConfigRegOffset]
+
+#else   /* We want a 2 DDR Bank setup then */
+
+        /* Group 0, Banks 0 & 1 -> ARM, Rd, Deterministic */
+        mov     r3, #0x0000
+        strh    r3, [r2, #MemifSdramArbGroup0SlotAConfigRegOffset]
+
+        /* Group 0, Banks 2 & 3 -> pA, Rd, Deterministic */
+        mov     r3, #0x0100
+        orr     r3, r3, #0x0001
+        strh    r3, [r2, #MemifSdramArbGroup0SlotBConfigRegOffset]
+
+        /* Group 1, Banks 0 & 1 -> ARM, Wr, Deterministic */
+        mov     r3, #0x0400
+        orr     r3, r3, #0x0004
+        strh    r3, [r2, #MemifSdramArbGroup1SlotAConfigRegOffset]
+
+        /* Group 1, Banks 2 & 3 -> pA, Wr Deterministic */
+        mov     r3, #0x0500
+        orr     r3, r3, #0x0005
+        strh    r3, [r2, #MemifSdramArbGroup1SlotBConfigRegOffset]
+
+        /* Valid Groups, 2 */
+        mov     r3, #0x0003
+        strh    r3, [r2, #MemifSdramArbValidGroupsConfigRegOffset]
+
+#endif
+
+/*****************************************************************************
+ SDRAM Setup
+*****************************************************************************/
+
+/* Set the SDRAM size and width */
+        mov     r3, #SdramSize13r10c
+        orr     r3, r3, #SdramWidth32
+        orr     r3, r3, #SdramRWGap4
+        orr     r3, r3, #SdramWRGap7
+        orr     r3, r3, #SdramOdt75Ohm
+        orr     r3, r3, #SdramCaptureDelay1Mclk
+        strh    r3, [r2,#MemifSdramSetupRegOffset]
+
+/* Set the refresh rate */
+        ldr     r3, =SdramRefreshCount
+        strh    r3, [r2, #MemifSdramRefreshRateRegOffset]
+
+/* Set the device mode register */
+        mov     r3, #0x0400
+        orr     r3, r3, #0x0042
+        strh    r3, [r2, #MemifSdramMrsRegOffset]
+
+/* Set the extended mode register */
+        ldr     r3, =SdramEmrsSetup
+        strh    r3, [r2, #MemifSdramErsRegOffset]
+
+/*****************************************************************************
+ Configuration complete, start the mem-if
+*****************************************************************************/
+        mov     r3, #SdramSetupComplete
+        strh    r3, [r2, #MemifSdramSetupCompleteReg]
+        mov     r3, #SramSetupComplete
+        strh    r3, [r2, #MemifSramSetupCompleteReg]
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * ddr2_dummy_access
+ *
+ * Description: Perform a 'dummy' write to and read back from the DDR2 SDRAM
+ *
+ *****************************************************************************/
+.global ddr2_dummy_access
+
+ ddr2_dummy_access:
+        ldr     r0, =PHYS_SDRAM_1
+        mov     r1, #0x00000000
+        str     r1, [r0]    /* perform a 'dummy' write */
+
+        ldr     r2, [r0]    /* perform a 'dummy' read */
+        cmp     r1, r2      /* ignore the result */
+
+        mov	pc, lr      /* Return to my caller */
+
+/*****************************************************************************
+ *
+ * register_initialisation
+ *
+ * Description: Initialise some CPU registers
+ *
+ * Note:
+ * Used to prevent X propagation if running this code in a simulation
+ *
+ *****************************************************************************/
+
+register_initialisation:
+
+        mov     r0, #0x00000000
+        mov     r1, #0x00000000
+        mov     r2, #0x00000000
+        mov     r3, #0x00000000
+        mov     r4, #0x00000000
+        mov     r5, #0x00000000
+        mov     r6, #0x00000000
+        mov     r7, #0x00000000
+        mov     r8, #0x00000000
+        mov     r9, #0x00000000
+        mov     r10,#0x00000000
+
+        /* Don't noodle with r11 (fp)
+                             r12 (ip)
+                             r13 (sp)
+                             r14 (lr)
+                             r15 (pc)
+           as this would cause big probs ! */
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * assertBootError
+ *
+ * Illuminate LED15 on the picoChip CPE20x hardware platform
+ *
+ *****************************************************************************/
+ .global assertBootError
+
+ assertBootError:
+
+         /* Get base address of the gpio block */
+        ldr r0,=PC20X_GPIO_BASE
+
+        /* Set up ARM gpio bit #5 as an o/p */
+        ldr r1,[r0, #GpioPortADataDirectionRegOffset]
+        orr r1,r1,#Gpio(5)
+        str r1,[r0, #GpioPortADataDirectionRegOffset]
+
+        /* Switch LED to RED on the ip202ff Platform */
+        ldr r1,[r0, #GpioPortAOutputDataRegOffset]
+        bic r1,r1,#Gpio(5)
+        str r1,[r0, #GpioPortAOutputDataRegOffset]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * extinguishArmLeds
+ *
+ * Extinguish both ARM controlled LEDS on the CPE20x Platform
+ *
+ *****************************************************************************/
+
+.global extinguishArmLeds
+
+extinguishArmLeds:
+
+        /* Get base address of the gpio block */
+        ldr r0,=PC20X_GPIO_BASE
+
+        /* Setup ARM gpio bit #5 as an output */
+        ldr r1,[r0, #GpioPortADataDirectionRegOffset]
+        orr r1,r1,#Gpio(5)
+        str r1,[r0, #GpioPortADataDirectionRegOffset]
+
+        /* Switch LED to GREEN on the ip202ff Platform */
+        ldr r1,[r0, #GpioPortAOutputDataRegOffset]
+        orr r1,r1,#Gpio(5)
+        str r1,[r0, #GpioPortAOutputDataRegOffset]
+
+        /* Return to my caller */
+        mov     pc, lr
+
+       .end
diff -Naur pico_1.3.4/board/ipaccess/ip202ff/u-boot.lds ipa_1.3.4/board/ipaccess/ip202ff/u-boot.lds
--- pico_1.3.4/board/ipaccess/ip202ff/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip202ff/u-boot.lds	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file u-boot.lds
+* \brief Used during the build process.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm926ejs/start.o (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur pico_1.3.4/board/ipaccess/ip302ff/Makefile ipa_1.3.4/board/ipaccess/ip302ff/Makefile
--- pico_1.3.4/board/ipaccess/ip302ff/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip302ff/Makefile	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,41 @@
+#/*****************************************************************************
+# * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+# *****************************************************************************/
+
+#/*!
+#* \file Makefile
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= pc7302.o mt29f2g08aadwp.o cmd_ip302ff.o
+SOBJS	:= lowlevel_init.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Naur pico_1.3.4/board/ipaccess/ip302ff/cmd_ip302ff.c ipa_1.3.4/board/ipaccess/ip302ff/cmd_ip302ff.c
--- pico_1.3.4/board/ipaccess/ip302ff/cmd_ip302ff.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip302ff/cmd_ip302ff.c	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,1639 @@
+/*
+ * (C) Copyright 2007 ip.access Ltd
+*/
+
+/*
+ * IP202FF platform timing/performance tests
+ *
+ * These tests are implemented as Board Specific U-boot commands.
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/mem_arm.h>
+#include <asm/arch/mem_shd.h>
+
+
+#if defined(CONFIG_CMD_BSP)
+
+/* number of iterations to run the read/write tests for */
+#define NUM_TEST_ITERATIONS     100000
+
+
+#define IOWRITE16(vALUE, aDDRESS)   *((volatile u16 *)(aDDRESS)) = (vALUE)
+#define IOREAD16(aDDRESS)           (*((volatile u16 *)(aDDRESS)))
+#define IOWRITE32(vALUE, aDDRESS)   *((volatile u32 *)(aDDRESS)) = (vALUE)
+#define IOREAD32(aDDRESS)           (*((volatile u32 *)(aDDRESS)))
+
+
+#define LED1_GPIO_NUM       2
+#define LED1_GPIO_BIT       (1 << LED1_GPIO_NUM)
+#define LED1_DATA_REG       (PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET)
+#define LED1_DIR_REG        (PC302_GPIO_BASE + GPIO_SW_PORT_A_DDR_REG_OFFSET)
+
+#define LED2_GPIO_NUM       3
+#define LED2_GPIO_BIT       (1 << LED2_GPIO_NUM)
+#define LED2_DATA_REG       (PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET)
+#define LED2_DIR_REG        (PC302_GPIO_BASE + GPIO_SW_PORT_A_DDR_REG_OFFSET)
+
+#define TIMER_NUM           1
+
+
+typedef enum MemTypeTag
+{
+    MT_SDRAM = 0,
+    MT_SRAM,
+    MT_FLASH,
+
+    NUM_MTS,
+
+    MT_FULL_TEST
+}
+MemType;
+
+typedef enum { LED_GREEN = 0x10, LED_RED = 0x11 } led_col;
+
+/*#define SHH_TEST*/
+#if defined(SHH_TEST)
+static void cp_delay (void)
+{
+    volatile int i;
+
+    /* copro seems to need some delay between reading and writing */
+    for (i = 0; i < 100; i++);
+}
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1 (void)
+{
+    unsigned long value;
+
+    __asm__ __volatile__(
+        "mrc    p15, 0, %0, c1, c0, 0   @ read control reg\n"
+        : "=r" (value)
+        :
+        : "memory");
+
+    return value;
+}
+
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1 (unsigned long value)
+{
+    __asm__ __volatile__(
+        "mcr    p15, 0, %0, c1, c0, 0   @ write it back\n"
+        :
+        : "r" (value)
+        : "memory");
+
+    read_p15_c1 ();
+}
+
+/* See also ARM926EJ-S Technical Reference Manual */
+#define C1_MMU      (1<<0)      /* mmu off/on */
+#define C1_ALIGN    (1<<1)      /* alignment faults off/on */
+#define C1_DC       (1<<2)      /* dcache off/on */
+
+#define C1_BIG_ENDIAN   (1<<7)      /* big endian off/on */
+#define C1_SYS_PROT (1<<8)      /* system protection */
+#define C1_ROM_PROT (1<<9)      /* ROM protection */
+#define C1_IC       (1<<12)     /* icache off/on */
+#define C1_HIGH_VECTORS (1<<13)     /* location of vectors: low/high addresses */
+
+void dcache_enable (void)
+{
+    ulong reg;
+
+    reg = read_p15_c1 ();       /* get control reg. */
+    cp_delay ();
+    write_p15_c1 (reg | C1_DC);
+}
+
+#endif  /* defined(SHH_TEST) */
+
+
+
+/*===========================================================================*/
+/* run the timcal command.
+ * This drives a LED low then high after a specified number of milliseconds.
+ * The tester should hook up the LED to a scope (or other timing device to
+ * time the pulse width.
+ */
+int do_timcal (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int             guardCount;
+    u32             gpioData;
+    u32             millisecondsForTest = 20;
+
+#if defined(SHH_TEST)
+printf ("Calling dcache_enable...\n");   /* SHH delete me!!! */
+dcache_enable ();   /* SHH delete me!!! */
+#endif  /* defined(SHH_TEST) */
+
+    switch (argc)
+    {
+    case 1:
+    case 2:
+        if (argc == 2)
+        {
+            int     dummy = simple_strtoul (argv[1], NULL, 10);
+            if ((dummy > 0) && (dummy <= 1000))
+            {
+                millisecondsForTest = dummy;
+            }
+            else
+            {
+                printf ("Bad milliseconds for test parameter - using %d\n", millisecondsForTest);
+            }
+        }
+
+        /* stop the timer */
+        IOWRITE32(0x0, PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+        /* load the count */
+        IOWRITE32((PC302_AHB_CLOCK_FREQ/(1000/millisecondsForTest)),
+                  PC302_TIMER_BASE + TIMERNLOADCOUNTREGOFFSET(TIMER_NUM));
+
+        /* set GPIO line to output for LED */
+        gpioData = IOREAD32(LED1_DIR_REG);
+        gpioData |= LED1_GPIO_BIT;
+        IOWRITE32(gpioData, LED1_DIR_REG);
+
+        /* ensure LED is off */
+        gpioData = IOREAD32(LED1_DATA_REG);
+        gpioData |= LED1_GPIO_BIT;
+        IOWRITE32(gpioData, LED1_DATA_REG);
+
+        guardCount = 1000000;
+        /* turn LED on */
+        gpioData &= ~LED1_GPIO_BIT;
+        IOWRITE32(gpioData, LED1_DATA_REG);
+
+        /* start the timer in user defined count mode */
+        IOWRITE32((TIMERENABLE|TIMERMODE), PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+        while (--guardCount > 0)
+        {
+            if (IOREAD32(PC302_TIMER_BASE + TIMERNINTERRUPTSTATUSREGOFFSET(TIMER_NUM)) != 0)
+            {
+                IOREAD32(PC302_TIMER_BASE + TIMERNEOIREGOFFSET(TIMER_NUM));
+                break;
+            }
+        }
+
+        /* turn LED off */
+        gpioData |= LED1_GPIO_BIT;
+        IOWRITE32(gpioData, LED1_DATA_REG);
+
+        if (guardCount <= 0)
+        {
+            printf ("ERROR: Failed to detect end of timer count period within a reasonable length of time!\n");
+        }
+        else
+        {
+            printf ("LED should have been turned on for %dms (use scope to check!)\n", millisecondsForTest);
+        }
+        return 0;
+
+    default:
+        printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+        return 1;
+    }
+
+    return 0;
+}
+
+
+/*===========================================================================*/
+#if defined(OLD_STYLE_TESTS)
+/*---------------------------------------------------------------------------*/
+static unsigned long mem_write_test (unsigned char *mem_p, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+    u32     count = (PC302_AHB_CLOCK_FREQ/1000) * testDurationMs;
+    int     guardCount = 100000000;
+    volatile u32 *m_p = (volatile u32 *)mem_p;
+    int     iStatus = icache_status ();
+
+    if (! iStatus)
+    {
+        printf ("Enabling I-Cache\n");
+        icache_enable ();
+    }
+
+
+    /* stop the timer */
+    IOWRITE32(0x0, PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+    /* load the count */
+    IOWRITE32(count, PC302_TIMER_BASE + TIMERNLOADCOUNTREGOFFSET(TIMER_NUM));
+
+    /* start the timer in user defined count mode */
+    IOWRITE32((TIMERENABLE|TIMERMODE), PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+    while (--guardCount > 0)
+    {
+        if (IOREAD32(PC302_TIMER_BASE + TIMERNINTERRUPTSTATUSREGOFFSET(TIMER_NUM)) != 0)
+        {
+            IOREAD32(PC302_TIMER_BASE + TIMERNEOIREGOFFSET(TIMER_NUM));
+            break;
+        }
+
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+        *m_p = 0x12345678;
+
+        numAccesses += 64;
+    }
+
+    if (! iStatus)
+    {
+        printf ("Disabling I-Cache\n");
+        icache_disable ();
+    }
+
+    if (guardCount <= 0)
+    {
+        printf ("ERROR: Failed to detect end of timer count period within a reasonable length of time!\n");
+    }
+
+    return numAccesses;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long mem_read_test (unsigned char *mem_p, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+    u32     count = (PC302_AHB_CLOCK_FREQ/1000) * testDurationMs;
+    int     guardCount = 100000000;
+    volatile u32 *m_p = (volatile u32 *)mem_p;
+    int     iStatus = icache_status ();
+
+    if (! iStatus)
+    {
+        printf ("Enabling I-Cache\n");
+        icache_enable ();
+    }
+
+    /* stop the timer */
+    IOWRITE32(0x0, PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+    /* load the count */
+    IOWRITE32(count, PC302_TIMER_BASE + TIMERNLOADCOUNTREGOFFSET(TIMER_NUM));
+
+    /* start the timer in user defined count mode */
+    IOWRITE32((TIMERENABLE|TIMERMODE), PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+    while (--guardCount > 0)
+    {
+        if (IOREAD32(PC302_TIMER_BASE + TIMERNINTERRUPTSTATUSREGOFFSET(TIMER_NUM)) != 0)
+        {
+            IOREAD32(PC302_TIMER_BASE + TIMERNEOIREGOFFSET(TIMER_NUM));
+            break;
+        }
+
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+        *m_p;
+
+        numAccesses += 64;
+    }
+
+    if (! iStatus)
+    {
+        printf ("Disabling I-Cache\n");
+        icache_disable ();
+    }
+
+    if (guardCount <= 0)
+    {
+        printf ("ERROR: Failed to detect end of timer count period within a reasonable length of time!\n");
+    }
+
+    return numAccesses;
+}
+
+/*---------------------------------------------------------------------------*/
+static void printTestResult (char *memType_p, unsigned long memAddr, int reading, int testDurationMs, unsigned long numAccesses)
+{
+    unsigned long   throughPut;
+    unsigned long   integral, decimal;
+
+    throughPut = ((((unsigned long)numAccesses)*4*8)/testDurationMs) + 5;
+
+    /* convert to 2 decimal places */
+    integral = throughPut/1000;
+    decimal = (throughPut % 1000)/10;
+
+    printf ("%-6s (0x%08lx): %10ld %s in %6d milliseconds. Throughput= %3ld.%02ld Mbps\n",
+            memType_p,
+            memAddr,
+            numAccesses,
+            (reading ? "Reads " : "Writes"),
+            testDurationMs,
+            integral,
+            decimal);
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long sdram_test (int reading, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+    u32     *mem_p = (u32 *)0x04000000;     /* spare SDRAM bank */
+
+    if (reading)
+    {
+        numAccesses = mem_read_test ((unsigned char *)mem_p, testDurationMs);
+    }
+    else
+    {
+        numAccesses = mem_write_test ((unsigned char *)mem_p, testDurationMs);
+    }
+
+    if (numAccesses <= 0)
+    {
+        printf ("SDRAM: No accesses - oops!\n");
+    }
+    else
+    {
+        printTestResult ("SDRAM", (unsigned long)mem_p, reading, testDurationMs, numAccesses);
+    }
+
+    return numAccesses;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long sram_test (int reading, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+
+    if (reading)
+    {
+        numAccesses = mem_read_test ((unsigned char *)PC302_ONCHIP_SRAM_BASE, testDurationMs);
+    }
+    else
+    {
+        numAccesses = mem_write_test ((unsigned char *)PC302_ONCHIP_SRAM_BASE, testDurationMs);
+    }
+
+    if (numAccesses <= 0)
+    {
+        printf ("SRAM: No accesses - oops!\n");
+    }
+    else
+    {
+        printTestResult ("SRAM", PC302_ONCHIP_SRAM_BASE, reading, testDurationMs, numAccesses);
+    }
+
+    return numAccesses;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long flash_test (int reading, int testDurationMs)
+{
+    unsigned long     numAccesses = 0;
+
+    if (reading)
+    {
+        numAccesses = mem_read_test ((unsigned char *)CFG_LOAD_ADDR, testDurationMs);
+    }
+    else
+    {
+        printf ("Flash WRITING not (yet) supported!\n");
+    }
+
+    if (numAccesses <= 0)
+    {
+        printf ("FLASH: No accesses - oops!\n");
+    }
+    else
+    {
+        printTestResult ("FLASH", CFG_LOAD_ADDR, reading, testDurationMs, numAccesses);
+    }
+
+    return numAccesses;
+}
+
+#else
+/*---------------------------------------------------------------------------*/
+static unsigned long mem2write_test (unsigned char *mem_p, int numIterations, int dummyRun)
+{
+    volatile u32    *m_p = (volatile u32 *)mem_p;
+    int             iStatus = icache_status ();
+    int             i;
+    unsigned long   startCount = 0xffffffff;
+    unsigned long   endCount;
+
+    if (! iStatus)
+    {
+        printf ("Enabling I-Cache\n");
+        icache_enable ();
+    }
+
+
+    /* stop the timer */
+    IOWRITE32(0x0, PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+    /* load the count */
+    IOWRITE32(startCount, PC302_TIMER_BASE + TIMERNLOADCOUNTREGOFFSET(TIMER_NUM));
+
+    i = numIterations;
+
+    /* start the timer in user defined count mode */
+    IOWRITE32((TIMERENABLE|TIMERMODE), PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+    while (--i > 0)
+    {
+        if (! dummyRun)
+        {
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+            *m_p = 0x12345678;
+        }
+    }
+
+    endCount = IOREAD32(PC302_TIMER_BASE + TIMERNCURRENTVALUEREGOFFSET(TIMER_NUM));
+
+    if (IOREAD32(PC302_TIMER_BASE + TIMERNINTERRUPTSTATUSREGOFFSET(TIMER_NUM)) != 0)
+    {
+        printf ("WARNING: PIT looks likes it has wrapped!\n");
+    }
+
+    if (! iStatus)
+    {
+        printf ("Disabling I-Cache\n");
+        icache_disable ();
+    }
+
+printf ("TickCount=0x%08lx\n", (startCount - endCount));
+    return (startCount - endCount);
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long mem2read_test (unsigned char *mem_p, int numIterations, int dummyRun)
+{
+    volatile u32    *m_p = (volatile u32 *)mem_p;
+    int             iStatus = icache_status ();
+    int             i;
+    unsigned long   startCount = 0xffffffff;
+    unsigned long   endCount;
+
+    if (! iStatus)
+    {
+        printf ("Enabling I-Cache\n");
+        icache_enable ();
+    }
+
+    /* stop the timer */
+    IOWRITE32(0x0, PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+    /* load the count */
+    IOWRITE32(startCount, PC302_TIMER_BASE + TIMERNLOADCOUNTREGOFFSET(TIMER_NUM));
+
+    i = numIterations;
+
+    /* start the timer in user defined count mode */
+    IOWRITE32((TIMERENABLE|TIMERMODE), PC302_TIMER_BASE + TIMERNCONTROLREGOFFSET(TIMER_NUM));
+
+    while (--i > 0)
+    {
+        if (! dummyRun)
+        {
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+            *m_p;
+        }
+    }
+
+    endCount = IOREAD32(PC302_TIMER_BASE + TIMERNCURRENTVALUEREGOFFSET(TIMER_NUM));
+
+    if (IOREAD32(PC302_TIMER_BASE + TIMERNINTERRUPTSTATUSREGOFFSET(TIMER_NUM)) != 0)
+    {
+        printf ("WARNING: PIT looks likes it has wrapped!\n");
+    }
+
+    if (! iStatus)
+    {
+        printf ("Disabling I-Cache\n");
+        icache_disable ();
+    }
+
+printf ("TickCount=0x%08lx\n", (startCount - endCount));
+    return (startCount - endCount);
+}
+
+/*---------------------------------------------------------------------------*/
+static void printTest2Result (char *memType_p, unsigned long memAddr, int reading, int numIterations, unsigned long tickCount)
+{
+    unsigned long   throughPut;
+    unsigned long   integral, decimal;
+
+    throughPut = (((((unsigned long)numIterations)*64*8*4) / (tickCount/1000)) * (PC302_AHB_CLOCK_FREQ/1000)) + 5;
+    throughPut /= 1000;
+
+    /* convert to 2 decimal places */
+    integral = throughPut/1000;
+    decimal = (throughPut % 1000)/10;
+
+    printf ("%-6s (0x%08lx): %10ld %s in %6ld ms. Throughput= %3ld.%02ld Mbps\n",
+            memType_p,
+            memAddr,
+            ((unsigned long)numIterations*64),
+            (reading ? "Reads " : "Writes"),
+            tickCount/(PC302_AHB_CLOCK_FREQ/1000),
+            integral,
+            decimal);
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long sdram2test (int reading, int numIterations)
+{
+    unsigned long     tickCount = 0;
+    unsigned long     tickCount2 = 0;
+    u32     *mem_p = (u32 *)0x04000000;     /* spare SDRAM bank */
+
+    if (reading)
+    {
+        tickCount = mem2read_test ((unsigned char *)mem_p, numIterations, 0);
+        tickCount2 = mem2read_test ((unsigned char *)mem_p, numIterations, 1);
+    }
+    else
+    {
+        tickCount = mem2write_test ((unsigned char *)mem_p, numIterations, 0);
+        tickCount2 = mem2write_test ((unsigned char *)mem_p, numIterations, 1);
+    }
+
+    if (tickCount <= 0)
+    {
+        printf ("SDRAM: No accesses - oops!\n");
+    }
+    else
+    {
+        printTest2Result ("SDRAM", (unsigned long)mem_p, reading, numIterations, (tickCount - tickCount2));
+    }
+
+    return tickCount;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long sram2test (int reading, int numIterations)
+{
+    unsigned long     tickCount = 0;
+    unsigned long     tickCount2 = 0;
+
+    if (reading)
+    {
+        tickCount = mem2read_test ((unsigned char *)PC302_ONCHIP_SRAM_BASE, numIterations, 0);
+        tickCount2 = mem2read_test ((unsigned char *)PC302_ONCHIP_SRAM_BASE, numIterations, 1);
+    }
+    else
+    {
+        tickCount = mem2write_test ((unsigned char *)PC302_ONCHIP_SRAM_BASE, numIterations, 0);
+        tickCount2 = mem2write_test ((unsigned char *)PC302_ONCHIP_SRAM_BASE, numIterations, 1);
+    }
+
+    if (tickCount <= 0)
+    {
+        printf ("SRAM: No accesses - oops!\n");
+    }
+    else
+    {
+        printTest2Result ("SRAM", (unsigned long)PC302_ONCHIP_SRAM_BASE, reading, numIterations, (tickCount - tickCount2));
+    }
+
+    return tickCount;
+}
+
+/*---------------------------------------------------------------------------*/
+static unsigned long flash2test (int reading, int numIterations)
+{
+    unsigned long     tickCount = 0;
+    unsigned long     tickCount2 = 0;
+
+    if (reading)
+    {
+        tickCount = mem2read_test ((unsigned char *)CFG_LOAD_ADDR, numIterations, 0);
+        tickCount2 = mem2read_test ((unsigned char *)CFG_LOAD_ADDR, numIterations, 1);
+    }
+    else
+    {
+        printf ("Flash WRITING not (yet) supported!\n");
+    }
+
+    if (tickCount <= 0)
+    {
+        printf ("FLASH: No accesses - oops!\n");
+    }
+    else
+    {
+        printTest2Result ("FLASH", (unsigned long)CFG_LOAD_ADDR, reading, numIterations, (tickCount - tickCount2));
+    }
+
+    return tickCount;
+}
+
+#endif  /* defined(OLD_STYLE_TESTS) */
+
+
+/*---------------------------------------------------------------------------*/
+/* run the memcal command.
+ * This runs a number of read or write access as fast as it can in a set time period.
+ */
+int do_memcal (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+#if defined(OLD_STYLE_TESTS)
+    u32             testDurationMs = 2000;
+#endif  /* defined(OLD_STYLE_TESTS) */
+    int             argsOK = 1;
+    int             reading = 1;
+    MemType         memType = MT_SDRAM;
+    int             result = 0;
+
+    switch (argc)
+    {
+    case 2:
+        if (strcmp (argv[1], "full") == 0)
+        {
+            memType = MT_FULL_TEST;
+        }
+        else
+        {
+            argsOK = 0;
+        }
+        break;
+
+    case 3:
+        if (strcmp (argv[1], "sdram") == 0)
+        {
+            memType = MT_SDRAM;
+        }
+        else if (strcmp (argv[1], "sram") == 0)
+        {
+            memType = MT_SRAM;
+        }
+        else if (strcmp (argv[1], "flash") == 0)
+        {
+            memType = MT_FLASH;
+        }
+        else
+        {
+            printf ("Bad memory type\n");
+            argsOK = 0;
+        }
+
+        if (strcmp (argv[2], "r") == 0)
+        {
+            reading = 1;
+        }
+        else if (strcmp (argv[2], "w") == 0)
+        {
+            reading = 0;
+        }
+        else
+        {
+            printf ("Bad access type (r or w)\n");
+            argsOK = 0;
+        }
+        break;
+
+    default:
+        printf ("Bad number of arguments\n");
+        argsOK = 0;
+        break;
+    }
+
+
+    if (argsOK)
+    {
+        switch (memType)
+        {
+            case MT_SDRAM:
+#if defined(OLD_STYLE_TESTS)
+                sdram_test (reading, testDurationMs);
+#else
+                sdram2test (reading, NUM_TEST_ITERATIONS);
+#endif  /* defined(OLD_STYLE_TESTS) */
+                break;
+            case MT_SRAM:
+#if defined(OLD_STYLE_TESTS)
+                sram_test (reading, testDurationMs);
+#else
+                sram2test (reading, NUM_TEST_ITERATIONS);
+#endif  /* defined(OLD_STYLE_TESTS) */
+                break;
+            case MT_FLASH:
+#if defined(OLD_STYLE_TESTS)
+                flash_test (reading, testDurationMs);
+#else
+                flash2test (reading, NUM_TEST_ITERATIONS);
+#endif  /* defined(OLD_STYLE_TESTS) */
+                break;
+            case MT_FULL_TEST:
+                {
+                    int     iStatus = icache_status ();
+
+                    if (! iStatus)
+                    {
+                        printf ("Enabling I-Cache\n");
+                        icache_enable ();
+                    }
+
+#if defined(OLD_STYLE_TESTS)
+                    sdram_test (1, testDurationMs);
+                    sdram_test (0, testDurationMs);
+                    sram_test (1, testDurationMs);
+                    sram_test (0, testDurationMs);
+                    flash_test (1, testDurationMs);
+#else
+                    sdram2test (1, NUM_TEST_ITERATIONS);
+                    sdram2test (0, NUM_TEST_ITERATIONS);
+                    sram2test (1, NUM_TEST_ITERATIONS);
+                    sram2test (0, NUM_TEST_ITERATIONS);
+                    flash2test (1, NUM_TEST_ITERATIONS);
+#endif  /* defined(OLD_STYLE_TESTS) */
+
+                    if (! iStatus)
+                    {
+                        printf ("Disabling I-Cache\n");
+                        icache_disable ();
+                    }
+                }
+                break;
+            default:
+                printf ("Bad memory type - coding error!\n");
+                break;
+        }
+    }
+    else
+    {
+        result = 1;
+        printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+    }
+
+
+    return result;
+}
+
+/*===========================================================================*/
+static void reportHwConfig (void)
+{
+    unsigned long i;
+    unsigned long c1;
+    int     armMode;
+
+    asm ("mrs %0,cpsr":"=r" (i));
+    armMode = i & 0x1f;
+    printf ("ARM CPSR=0x%08lx (IRQ=%s, FIQ=%s, Thumb=%s, Mode=%s)\n",
+            i,
+            (i & 0x0080) ? "DISABLED" : "ENABLED",
+            (i & 0x0040) ? "DISABLED" : "ENABLED",
+            (i & 0x0020) ? "ENABLED"  : "DISABLED",
+            (armMode == 0x13) ? "Supervisor"
+                              : (armMode == 0x10) ? "User"
+                                                  : (armMode == 0x1f) ? "System"
+                                                                      : (armMode == 0x11) ? "FIQ"
+                                                                                          : (armMode == 0x12) ? "IRQ"
+                                                                                                              : "??????"
+           );
+
+    /* read c1 */
+    asm ("mrc p15, 0, %0, c1, c0, 0":"=r" (c1));
+    printf ("ARM CP15: Control (1)=0x%08lx  (I-Cache=%s, D-Cache=%s, MMU=%s)\n",
+            c1,
+            (c1 & 0x1000) ? "ON" : "OFF",
+            (c1 & 0x0004) ? "ON" : "OFF",
+            (c1 & 0x0001) ? "ON" : "OFF"
+           );
+}
+
+/*---------------------------------------------------------------------------*/
+static void reportMemArb (void)
+{
+    int                 i;
+    int                 slotOff;
+    unsigned short      value;
+    unsigned short      valid;
+    volatile unsigned short *armReg_p = (volatile unsigned short *)PC302_MEMIF_BASE;
+    volatile unsigned short *addr_p;
+
+    /* SDRAM */
+    addr_p = armReg_p + ADDR_SDRAM_VALID_GROUPS;
+    valid = IOREAD16(addr_p);
+
+    for (i=0; i<16; i++)
+    {
+        if (valid & (1 << (i/2)))
+        {
+            slotOff = ((i & 1) << 1);
+
+            addr_p = armReg_p + ADDR_SDRAM_ARB_G0_S0_S1 + i;
+            value = IOREAD16(addr_p);
+
+            printf ("SDRAM_arb_group_%d_Slot_%d = %s-%s,%s-%s,%dacc\n",
+                                        (i/2), slotOff,
+                                        (value & 0x0001) ? "pico" : "AXI ",
+                                        (value & 0x0002) ? "Opp" : "Det",
+                                        (value & 0x0004) ? "W" : "R",
+                                        (value & 0x0008) ? "Opp" : "Det",
+                                        (((value & 0x0030) >> 4) + 1)*8
+                   );
+            printf ("SDRAM_arb_group_%d_Slot_%d = %s-%s,%s-%s,%dacc\n",
+                                        (i/2), slotOff + 1,
+                                        (value & 0x0100) ? "pico" : "AXI ",
+                                        (value & 0x0200) ? "Opp" : "Det",
+                                        (value & 0x0400) ? "W" : "R",
+                                        (value & 0x0800) ? "Opp" : "Det",
+                                        (((value & 0x3000) >> 12) + 1)*8
+                   );
+        }
+    }
+    printf ("\n");
+
+
+    /* SRAM */
+    addr_p = armReg_p + ADDR_SRAM_VALID_SLOTS;
+    valid = IOREAD16(addr_p);
+
+    for (i=0; i<3; i++)
+    {
+        slotOff = i << 1;
+
+        addr_p = armReg_p + ADDR_SRAM_ARB_S0_S1 + i;
+        value = IOREAD16(addr_p);
+
+        if (valid & (1 << (2*i)))
+        {
+            printf ("SRAM_arb_Slot_%d = %s-%s,%s-%s,%dacc,%s\n",
+                                        slotOff,
+                                        (value & 0x0001) ? "pico" : "AXI ",
+                                        (value & 0x0002) ? "Opp" : "Det",
+                                        (value & 0x0004) ? "W" : "R",
+                                        (value & 0x0008) ? "Opp" : "Det",
+                                        (1 << ((value & 0x0030) >> 4)),
+                                        ((value & 0x0001) ? ((value & 0x0040) ? "Buff1" : "Buff0")
+                                                        : ((value & 0x0002) ? ((value & 0x0040) ? "Buff1" : "Buff0")
+                                                                            : "-"
+                                                            )
+                                        )
+                   );
+        }
+
+        if (valid & (1 << (2*i + 1)))
+        {
+            printf ("SRAM_arb_Slot_%d = %s-%s,%s-%s,%dacc,%s\n",
+                                        slotOff + 1,
+                                        (value & 0x0100) ? "pico" : "AXI ",
+                                        (value & 0x0200) ? "Opp" : "Det",
+                                        (value & 0x0400) ? "W" : "R",
+                                        (value & 0x0800) ? "Opp" : "Det",
+                                        (1 << ((value & 0x3000) >> 12)),
+                                        ((value & 0x0100) ? ((value & 0x4000) ? "Buff1" : "Buff0")
+                                                        : ((value & 0x0200) ? ((value & 0x4000) ? "Buff1" : "Buff0")
+                                                                            : "-"
+                                                            )
+                                        )
+                   );
+        }
+    }
+    printf ("\n");
+}
+
+
+/*---------------------------------------------------------------------------*/
+static void reportSdramCfg (void)
+{
+    volatile unsigned short *armReg_p = (volatile unsigned short *)PC302_MEMIF_BASE;
+    volatile unsigned short *addr_p;
+
+    /* SDRAM */
+#if 0
+    addr_p = armReg_p + (DLL0SlaveAdjustRegOffset/2);
+    printf ("SDRAM DLL Slave Adjusts: 0x%04x  0x%04x  0x%04x  0x%04x\n",
+            IOREAD16(addr_p),
+            IOREAD16((addr_p + 3)),
+            IOREAD16((addr_p + 6)),
+            IOREAD16((addr_p + 9)));
+#endif
+
+    addr_p = armReg_p + ADDR_SDRAM_SETUP;
+    printf ("SDRAM Setup: 0x%04x\n", IOREAD16(addr_p));
+
+    addr_p = armReg_p + ADDR_SDRAM_REFRESH;
+    printf ("SDRAM Refresh Rate: 0x%04x\n", IOREAD16(addr_p));
+
+    addr_p = armReg_p + ADDR_SDRAM_MRS;
+    printf ("SDRAM Mode: 0x%04x\n", IOREAD16(addr_p));
+
+    addr_p = armReg_p + ADDR_SDRAM_EMRS;
+    printf ("SDRAM EMRS: 0x%04x\n", IOREAD16(addr_p));
+
+    addr_p = armReg_p + ADDR_SDRAM_EMRS2;
+    printf ("SDRAM EMRS2: 0x%04x\n", IOREAD16(addr_p));
+
+    addr_p = armReg_p + ADDR_SDRAM_EMRS3;
+    printf ("SDRAM EMRS3: 0x%04x\n", IOREAD16(addr_p));
+
+    printf ("\n");
+}
+
+/*---------------------------------------------------------------------------*/
+/* run the memcfg command.
+ */
+int do_memcfg (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int     result = 0;
+    switch (argc)
+    {
+    case 1:
+/* for one-off test, changed CAS strobe - gave 1% increase in SDRAM reads (no affact on writes) */
+/* *((volatile u16 *)(PC302_MEMIF_BASE + MemifSdramMrsRegOffset)) = 0x443;*/
+        reportHwConfig ();
+        reportMemArb ();
+        reportSdramCfg ();
+        break;
+
+    default:
+        printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+        result = 1;
+        break;
+    }
+
+    return result;
+}
+
+
+/*===========================================================================*/
+#define SDRAM_CFG_DATA_SIZE     17
+typedef unsigned short SDRAM_CFG_DATA [SDRAM_CFG_DATA_SIZE];
+
+#define SRAM_CFG_DATA_SIZE      4
+typedef unsigned short SRAM_CFG_DATA [SRAM_CFG_DATA_SIZE];
+
+
+#define MAX_SDRAM_CFGS          5
+SDRAM_CFG_DATA  sdramCfgData [MAX_SDRAM_CFGS] =
+{   /* just ARM access */
+    {0x0000, 0x0000, 0x0404, 0x0404, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x0003
+    },
+
+    /* ARM + pico equal access */
+    {0x0404, 0x0404, 0x0505, 0x0505, 0x0000, 0x0000, 0x0101, 0x0101,
+     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x000f
+    },
+
+    /* ARM (det) + pico (opp) access */
+    {0x0404, 0x0404, 0x0707, 0x0707, 0x0000, 0x0000, 0x0303, 0x0303,
+     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x000f
+    },
+
+    /* ARM (opp) + pico (opp) access */
+    {0x0606, 0x0606, 0x0707, 0x0707, 0x0202, 0x0202, 0x0303, 0x0303,
+     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+     0x000f
+    },
+
+    /* just ARM - but using all groups */
+    {0x0000, 0x0000, 0x0404, 0x0404, 0x0000, 0x0000, 0x0404, 0x0404,
+     0x0000, 0x0000, 0x0404, 0x0404, 0x0000, 0x0000, 0x0404, 0x0404,
+     0x00ff
+    },
+};
+
+#define MAX_SRAM_CFGS           3
+SRAM_CFG_DATA   sramCfgData [MAX_SRAM_CFGS] =
+{   /* just ARM access */
+    {0x0004, 0x0000, 0x0000,
+     0x0003
+    },
+
+    /* ARM + pico equal access */
+    {0x0504, 0x0045, 0x4101,
+     0x003f
+    },
+
+    /* ARM (det) + pico (opp) access */
+    {0x0704, 0x0047, 0x4303,
+     0x003f
+    }
+};
+
+
+static void sdramConfig (int sdramCfg)
+{
+    int                 i;
+    volatile unsigned short *addr_p = ((volatile unsigned short *)PC302_MEMIF_BASE) + ADDR_SDRAM_ARB_G0_S0_S1;
+    SDRAM_CFG_DATA      *cfgData_p  = &sdramCfgData [sdramCfg];
+
+    for (i=0; i<SDRAM_CFG_DATA_SIZE; i++)
+    {
+        IOWRITE16((*cfgData_p) [i], addr_p);
+
+        addr_p++;
+    }
+
+    /* make it so */
+    addr_p = ((volatile unsigned short *)PC302_MEMIF_BASE) + 0x4f;
+    IOWRITE16(0x0001, addr_p);
+
+    while ((IOREAD16(addr_p) & 0x0001) == 0x0001)
+    {
+    }
+}
+
+/*-----------------------------------------------------------------------*/
+static void sramConfig (int sramCfg)
+{
+    int                 i;
+    volatile unsigned short *addr_p = ((volatile unsigned short *)PC302_MEMIF_BASE) + 0x40;
+    SRAM_CFG_DATA       *cfgData_p  = &sramCfgData [sramCfg];
+
+    for (i=0; i<SRAM_CFG_DATA_SIZE; i++)
+    {
+        IOWRITE16((*cfgData_p) [i], addr_p);
+
+        addr_p++;
+    }
+
+    /* make it so */
+    addr_p = ((volatile unsigned short *)PC302_MEMIF_BASE) + 0x4f;
+    IOWRITE16(0x0002, addr_p);
+
+    while ((IOREAD16(addr_p) & 0x0002) == 0x0002)
+    {
+    }
+}
+
+/*---------------------------------------------------------------------------*/
+/* run the memarb command.
+ */
+int do_memarb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int     result = 0;
+    int     i;
+    int     len;
+    int     argsOK = 1;
+    int     sdramCfg = -1;
+    int     sramCfg = -1;
+
+    switch (argc)
+    {
+    case 1:
+        reportHwConfig ();
+        reportMemArb ();
+        reportSdramCfg ();
+        break;
+
+    default:
+        /*-----------------------------------------------------------------------*/
+        /* input parameter checking ... */
+        for (i=1; i< argc; i++)
+        {
+            if (strncmp (argv[i], "sdram", 5) == 0)
+            {
+                len = strlen (argv[i]);
+                if (len != 6)
+                {
+                    argsOK = 0;
+                }
+                else
+                {
+                    char    ch = argv[i][5];
+                    if ((ch < '0') || (ch > '9'))
+                    {
+                        argsOK = 0;
+                    }
+                    else
+                    {
+                        sdramCfg = ch - '0';
+                        if (sdramCfg >= MAX_SDRAM_CFGS)
+                        {
+                            argsOK = 0;
+                        }
+                    }
+                }
+            }
+            else if (strncmp (argv[i], "sram", 4) == 0)
+            {
+                len = strlen (argv[i]);
+                if (len != 5)
+                {
+                    argsOK = 0;
+                }
+                else
+                {
+                    char    ch = argv[i][4];
+                    if ((ch < '0') || (ch > '9'))
+                    {
+                        argsOK = 0;
+                    }
+                    else
+                    {
+                        sramCfg = ch - '0';
+                        if (sramCfg >= MAX_SRAM_CFGS)
+                        {
+                            argsOK = 0;
+                        }
+                    }
+                }
+            }
+            else
+            {
+                argsOK = 0;
+            }
+        }
+
+        if (argsOK)
+        {
+            if (sdramCfg != -1)
+            {
+                sdramConfig (sdramCfg);
+            }
+
+            if (sramCfg != -1)
+            {
+                sramConfig (sramCfg);
+            }
+        }
+        else
+        {
+            printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+            result = 1;
+        }
+        break;
+    }
+
+    return result;
+}
+
+
+/* setLED - change state of the LED
+ */
+void setLED(led_col col)
+{
+    u32  gpioData;
+
+    if (col == LED_GREEN)
+    {
+        /* set GPIO line to output for LED */
+        gpioData = IOREAD32(LED2_DIR_REG);
+        gpioData |= LED2_GPIO_BIT;
+        IOWRITE32(gpioData, LED2_DIR_REG);
+
+        /* ensure LED is on/green */
+        gpioData = IOREAD32(LED2_DATA_REG);
+        gpioData |= LED2_GPIO_BIT;
+        IOWRITE32(gpioData, LED2_DATA_REG);
+    }
+    else if (col == LED_RED)
+    {
+        /* set GPIO line to output for LED */
+        gpioData = IOREAD32(LED2_DIR_REG);
+        gpioData |= LED2_GPIO_BIT;
+        IOWRITE32(gpioData, LED2_DIR_REG);
+
+        /* ensure LED is off/red */
+        gpioData = IOREAD32(LED2_DATA_REG);
+        gpioData &= ~LED2_GPIO_BIT;
+        IOWRITE32(gpioData, LED2_DATA_REG);
+    }
+}
+
+/*---------------------------------------------------------------------------*/
+/* run the set_led command.
+ */
+int do_set_led (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    int     result = 1;
+
+    if (argc == 2)
+    {
+        if (strcmp (argv[1], "green") == 0)
+        {
+            setLED(LED_GREEN);
+            result = 0;
+        }
+        else if (strcmp (argv[1], "red") == 0)
+        {
+            setLED(LED_RED);
+            result = 0;
+        }
+    }
+
+    if (result)
+    {
+        printf ("Usage:\n%s%s\n", cmdtp->usage, cmdtp->help);
+    }
+
+    return result;
+}
+
+
+#ifdef CONFIG_BOOTCOUNT_LIMIT
+
+#define SRAM_BOOT_VARS_ADDRESS (PC302_ONCHIP_SRAM_BASE + PC302_ONCHIP_SRAM_SIZE - 0x40)
+
+void bootcount_init (void)
+{
+	volatile ulong *save_addr =
+		(volatile ulong *)(SRAM_BOOT_VARS_ADDRESS);
+	int i;
+
+	if (save_addr[15] != BOOTCOUNT_MAGIC)
+	{
+		for(i=0; i<15; i++)
+			save_addr[i] = 0;
+		save_addr[15] = BOOTCOUNT_MAGIC;
+	}
+}
+
+void bootcount_store (ulong a)
+{
+	volatile ulong *save_addr =
+		(volatile ulong *)(SRAM_BOOT_VARS_ADDRESS);
+
+	bootcount_init();  // Initialise boot variables if no BOOTCOUNT_MAGIC
+	save_addr[14] = a;
+}
+
+ulong bootcount_load (void)
+{
+	volatile ulong *save_addr =
+		(volatile ulong *)(SRAM_BOOT_VARS_ADDRESS);
+
+	if (save_addr[15] != BOOTCOUNT_MAGIC)
+		return 0;
+	else
+		return save_addr[14];
+}
+
+#endif /* CONFIG_BOOTCOUNT_LIMIT */
+
+#ifdef CONFIG_VERIFY_KERNEL
+extern unsigned long do_go_exec (ulong (*entry)(int, char *[]), int argc, char *argv[]);
+
+/**********************************************************************
+ * do_verify_kernel
+ *
+ * Attempt to verify digital signature of kernel image being booted.
+ * This is called from bootm. On the first failure the bootcount is set
+ * to 100 and we return the failure code, which in turn causes the
+ * bootm to fail. On the second failure we halt.
+ *
+ *********************************************************************/
+int do_verify_kernel(ulong start, ulong end)
+{
+	ulong	addr, rc;
+	char *argv[2];
+	char start_str[16];
+
+	sprintf(start_str, "0x%08lX", start);
+	addr = VALIDATE_APP_ADDR;
+	argv[0] = "validate_app";
+	argv[1] = start_str;
+
+	printf ("## Attempting verify image @%s with app @0x%08lX...\n", argv[1], addr);
+
+	bootcount_init();
+
+	rc = do_go_exec ((void *)addr, 2, argv);
+
+	if (rc)
+	{
+		printf("Validation failed with rc=%ld\n", rc);
+		if (bootcount_load() == 100)
+		{
+			/* already tried the other bank.. give up */
+			setLED(LED_RED);
+			printf("No valid kernel images found!\n");
+			for (;;) {}
+		}
+		else
+		{
+			/* set bootcount to 100 to indicate that an attempt to
+			 * to verify this bank failed.
+			 */
+			bootcount_store(100);
+		}
+	}
+
+	return rc;
+}
+#endif /* CONFIG_VERIFY_KERNEL */
+
+/*===========================================================================*/
+
+U_BOOT_CMD(
+    timcal,   2,   1,     do_timcal,
+    "timcal  - calibrate timing (via LED and using scope)\n",
+    "  args: <N> - number of milliseconds to drive LED high (beware arithmetic rounding issues!)"
+);
+
+
+U_BOOT_CMD(
+    memcal,   3,   1,     do_memcal,
+    "memcal  - calibrate memory read or write timing (assumes timing calibrated successfully - see timcal)\n",
+    "  args: [sdram | sram | flash] [r | w] - type of memory + read or write"
+);
+
+
+U_BOOT_CMD(
+    memcfg,   1,   1,     do_memcfg,
+    "memcfg  - report ARM/PC202 configuration affecting memory access speed\n",
+    ""
+);
+
+
+U_BOOT_CMD(
+    memarb,   3,   1,     do_memarb,
+    "memarb  - report/change SDRAM/SRAM arbitration scheme\n",
+    "  args: [sdram<n>] [sram<m>] where:-\n"
+    "    sdram<n> configures SDRAM config number n\n"
+    "          0 => just ARM access\n"
+    "          1 => ARM + pico equal access\n"
+    "          2 => ARM (deterministic) + pico (opportunistic) access\n"
+    "          3 => ARM (opportunistic) + pico (opportunistic) access\n"
+    "          4 => just ARM access - all 8 groups\n"
+    "    sram<m> configures SRAM config number m\n"
+    "          0 => just ARM access\n"
+    "          1 => ARM + pico equal access\n"
+    "          2 => ARM (deterministic) + pico (opportunistic) access\n"
+);
+
+U_BOOT_CMD(
+    set_led,   2,   1,     do_set_led,
+    "set_led - change colour of Sys/Pwr LED\n",
+    "  args: [red | green]"
+);
+
+#endif	/* CFG_CMD_CACHE */
+
+int raise (int signum)
+{
+       printf("raise: Signal # %d caught\n", signum);
+       return 0;
+}
+
diff -Naur pico_1.3.4/board/ipaccess/ip302ff/config.mk ipa_1.3.4/board/ipaccess/ip302ff/config.mk
--- pico_1.3.4/board/ipaccess/ip302ff/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip302ff/config.mk	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,47 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file config.mk
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2009 picoChip Designs Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+# The PC7203 U-Boot image should be re-located to address...
+TEXT_BASE = 0x06000000
+
+ifdef BSP_DIR
+include $(BSP_DIR)/config
+PLATFORM_CPPFLAGS += -DPICOCHIP_PLATFORM_VERSION=\"$(RELEASE_VERSION)\"
+endif
+
+ifeq ($(PC7302_RUN_FROM_RAM), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_RUN_FROM_RAM
+endif
+
+#/* Include support / commands for NAND Flash
+# *
+# * Note: Please read the comments in file
+# *       board/picochip/pc7302/mt29f2g08aadwp.c about gpio pins used
+# *       and PC302 booting modes before defining CONFIG_CMD_NAND
+# */
+ifeq ($(PC7302_NAND_SUPPORT), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_CMD_NAND
+endif
+
+ifeq ($(PC7302_UBIFS), Y)
+PLATFORM_CPPFLAGS += -DPICO_USE_UBIFS
+endif
+
+ifeq ($(PC7302_THUMB), Y)
+PLATFORM_CPPFLAGS += -DBUILD_FOR_THUMB
+
+endif
diff -Naur pico_1.3.4/board/ipaccess/ip302ff/lowlevel_init.S ipa_1.3.4/board/ipaccess/ip302ff/lowlevel_init.S
--- pico_1.3.4/board/ipaccess/ip302ff/lowlevel_init.S	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip302ff/lowlevel_init.S	2011-04-26 11:55:41.000000000 +0100
@@ -0,0 +1,481 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file lowlevel_init.S
+* \brief Various low level setup functions.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <config.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/mem_arm.h>
+#include <asm/arch/mem_shd.h>
+#include <asm/arch/ebi.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pa.h>
+#include <asm/arch/axi2cfg.h>
+
+/* Macros ------------------------------------------------------------------ */
+/* This gives us a peripheral bus base address of 0x80000000
+   and a memory region size of 4Mbytes */
+#define PERIPHERAL_BUS_SETUP        0x8000000D
+
+#define ASSERT_BOOT_ERROR_PIN       0
+#define NEGATE_BOOT_ERROR_PIN       1
+#define BOOT_ERROR_PIN_IS_OUTPUT    1
+
+#define GREEN_LED_PIN_BIT           (1<<3)
+
+/* Prototypes--------------------------------------------------------------- */
+
+/* Macros ------------------------------------------------------------------ */
+
+/*****************************************************************************
+ *
+ * configWriteLoadFile
+ *
+ *****************************************************************************/
+.macro  configWriteLoadFile Reg0, Reg1, Reg2, Reg3, Reg4, lfbase, lfwords
+
+        LDR     \Reg0,=\lfbase
+
+        /* We are running in Flash at this point therefore we
+           must 'noodle' with the linker created address
+           for the 'lfbase' address
+           We need to check if we're running from the base of
+           Flash and add offset if not */
+        SUBS    \Reg0, \Reg0, #TEXT_BASE
+        TST     pc, #(CFG_MONITOR_BASE-CFG_FLASH_BASE)
+        ADDNE   \Reg0, \Reg0, #(CFG_MONITOR_BASE-CFG_FLASH_BASE)
+
+        LDR     \Reg1,=PC302_AXI2CFG_BASE
+        LDR     \Reg2,=\lfwords
+0:
+        LDR     \Reg3, [\Reg0],#0x4
+        STR     \Reg3, [\Reg1,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        SUBS    \Reg2, \Reg2, #1
+        BNE     0b
+.endm
+
+/*****************************************************************************
+ *
+ * configRead
+ *
+ *****************************************************************************/
+.macro  configRead Reg0, Reg1, Reg2, aeid, addr
+
+        LDR     \Reg0,=PC302_AXI2CFG_BASE
+
+        /* aeid */
+        LDR     \Reg1,=\aeid
+        ORR     \Reg1,\Reg1,#PA_CONFIG_AEID
+        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+
+        /* addr */
+        LDR     \Reg1,=\addr
+        ORR     \Reg1,\Reg1,#PA_CONFIG_ADDR
+        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+
+        /* data */
+        MOV     \Reg1,#PA_CONFIG_READ
+        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        MOV     \Reg2,#0x20
+
+        /* read */
+0:
+        LDR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_READ_REG_OFFSET]
+        TST     \Reg1, #(PA_CONFIG_VALID | PA_CONFIG_FAIL)
+        BNE     1f
+        SUBS    \Reg2,\Reg2,#1
+        BNE     0b
+        MOV     \Reg1, #PA_CONFIG_TIMEOUT
+1:
+        MOV     \Reg0, \Reg1
+
+.endm
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * lowlevel_init
+ *
+ * Description: Perform some low level PC302 initialisation
+ *
+ *****************************************************************************/
+ .global lowlevel_init
+
+ lowlevel_init:
+
+        /* Preserve link register across call */
+        mov     r11,lr
+
+        /* Setup the Periheral Port Memory Remap Register */
+        LDR     r0, =PERIPHERAL_BUS_SETUP
+        MCR     p15, 0, r0, c15, c2, 4
+
+#ifdef CONFIG_PC302_SIMULATION
+        bl      register_initialisation
+#endif
+
+        /* Initialise the PAI/GPIO pin multiplexing */
+        bl      initialisePaiGpioPinMultiplexing
+
+        /* Setup the ebi memory interface (Flash Memory) */
+        bl      ebi_init
+
+        /* Initialise the boot error pin */
+        bl      initialiseBootErrorPin
+
+        /* Setup the ARM memory interface */
+        bl      memif_arm_init
+
+        /* Set up the Shared memory interface */
+        bl      memif_shared_init
+
+        /* Restore link register */
+        mov     lr, r11
+
+        /* Return to my caller */
+        mov	pc, lr
+
+ /*****************************************************************************
+ *
+ * ebi_init
+ *
+ * Description: Initialise the External Bus Interface
+ *
+ * Note:
+ * In here we just 'tweak' the default values set in hardware to match
+ * the Flash memory timings of the devices used on the hardware platform.
+ *
+ *****************************************************************************/
+
+ebi_init:
+        ldr     r2, =PC302_EBI_BASE
+        
+        /* Get current setting of SMTMGR_SET0 */
+        ldr     r3, [r2, #STATIC_MEM_TIMSET0_REG_OFFSET]
+        
+        /* Set tas to 15ns */
+        bic     r3, r3, #(EBI_SMTMGR_REG_ADDR_SETUP_MASK << EBI_SMTMGR_REG_ADDR_SETUP_SHIFT)
+        orr     r3, r3, #(3 << EBI_SMTMGR_REG_ADDR_SETUP_SHIFT)
+        
+        /* Set twr to 15ns */
+        bic     r3, r3, #(EBI_SMTMGR_REG_ADDR_HOLD_MASK << EBI_SMTMGR_REG_ADDR_HOLD_SHIFT)
+        orr     r3, r3, #(3 << EBI_SMTMGR_REG_ADDR_HOLD_SHIFT)
+        
+        /* Write new setting back to SMTMGR_SET0 */
+        str     r3, [r2, #STATIC_MEM_TIMSET0_REG_OFFSET]
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * memif_arm_init
+ *
+ * Description: Initialise the ARM Memory Controller
+ *
+ *****************************************************************************/
+memif_arm_init:
+
+        LDR     r3, =PC302_MEMIF_BASE
+
+        /* ;; =MEMIF_ARM_DRAM_INIT_PARAM_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_MSK << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
+        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_VAL << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
+        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
+        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
+        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
+        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
+        STR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_0_OFFSET */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx16
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_0_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_1_OFFSET */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx16
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_1_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_2_OFFSET */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx16
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_2_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_PARAM_2_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+        AND     r4, r4, #0xFFFFFFF0
+        ORR     r4, r4, #0x00000004 ; wl = cl - 2
+        STR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_BL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+        BIC     r4, r4, #0x00000001 //; bl = 4
+        STR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+
+        /* ;;  =MEMIF_ARM_DRAM_INIT_PARAM_OFFSET (0x0A) */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+        AND     r4, r4, #0
+        ORR     r4, r4, #0x00000008 //; 0x05009408 is a picoChip recommendation, 02/11/09
+        ORR     r4, r4, #0x00009400
+        ORR     r4, r4, #0x05000000
+        STR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+
+        /* ;;  =MEMIF_ARM_DRAM_EMR_MR_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+        AND     r4, r4, #0xFFFFFF88
+        ORR     r4, r4, #0x00000002 //; bl = 4
+        ORR     r4, r4, #0x00000060 //; cl = 6
+        ORR     r4, r4, #0x04000000 //; dqs# = 0
+        AND     r4, r4, #0xFFBBFFFF
+        ORR     r4, r4, #0x00040000 //; odt = 75ohms
+        STR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+
+        /* ;;  =MEMIF_ARM_PHY_CMD_RDC_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+        AND     r4, r4, #0xFFFFFF00
+        ORR     r4, r4, #0x00000050 //;  phy wl
+        ORR     r4, r4, #0x00000006 //;  phy rl
+        AND     r4, r4, #0xFFFFFCFF
+        ORR     r4, r4, #0x00000300 //;  rdc_we_to_re_delay = 3 clks
+        AND     r4, r4, #0xFFFEFFFF
+        ORR     r4, r4, #0x00010000 //;  use_fixed_re = 1
+        STR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_SLV_DLL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
+        AND     r4, r4, #0x0
+        ORR     r4, r4, #0x30000000 //;  dll rd_slave1 ratio
+        ORR     r4, r4, #0x00300000 //;  dll rd_slave0 ratio
+        ORR     r4, r4, #0x00000040 //;  dll wr_slave ratio
+        STR     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_ODT_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_ODT_OFFSET]
+        BIC     r4, r4, #0x00000001 //; disable dram odt during reads
+        STR     r4, [r3,#MEMIF_ARM_DRAM_ODT_OFFSET]
+
+        /* ;; =MEMIF_ARM_ODT_CTRL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+        AND     r4, r4, #0xFFFFFF00
+        AND     r4, r4, #0xFFFF00FF
+        ORR     r4, r4, #0x0010 //; wr_odt_delay, cl-5
+        ORR     r4, r4, #0x3000 //; wr_odt_hold, 4 cycles required
+        STR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_LOCAL_ODT_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+        AND     r4, r4, #0xFFFFFFC0
+        ORR     r4, r4, #0x0001 //; rd_local_odt = 75 ohm
+                                //; wr_local_odt = off
+                                //; idle_local_odt = off
+        STR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET]
+        ORR     r4, r4, #0x0010 //; fifo_we_in odt = 75 ohm
+        ORR     r4, r4, #0x000F //; All control signals half drive strength
+        STR     r4, [r3, #MEMIF_ARM_GP2_OFFSET]
+
+        /* ;; =MEMIF_ARM_INDIRECT_RW_CMD_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+        ORR     r4, r4, #0x1  //; de-assert soft reset
+        STR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+
+/* Check to see if the mem-if ARM is ready yet? */
+memif_arm_init_poll:
+        LDR     r4, [r3, #MEMIF_ARM_CTRL_MODE_OFFSET]
+        AND     r4, r4, #0x3
+        CMP     r4, #0x1
+        BNE     memif_arm_init_poll
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * memif_shared_init
+ *
+ * Description: Initialise the Shared Memory Controller
+ *
+ *****************************************************************************/
+
+/* Data to set-up the memif-Shared Shared, this is effectively a load file */
+
+memif_shared_init_data:
+        .word   LF_PA_AEID_MEMIF, LF_CBFM_SLEEPREG_ADDR, PA_WRITE_ZERO_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G0_S0_S1, ADDR_SDRAM_ARB_G0_S0_S1_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G0_S2_S3, ADDR_SDRAM_ARB_G0_S2_S3_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G1_S0_S1, ADDR_SDRAM_ARB_G1_S0_S1_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G1_S2_S3, ADDR_SDRAM_ARB_G1_S2_S3_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_VALID_GROUPS, ADDR_SDRAM_VALID_GROUPS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_SETUP, ADDR_SDRAM_SETUP_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_REFRESH, ADDR_SDRAM_REFRESH_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ODT_SETUP, ADDR_SDRAM_ODT_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_AXI_CONFIG, ADDR_SDRAM_AXI_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_MRS, ADDR_SDRAM_MRS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_EMRS, ADDR_SDRAM_EMRS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_CONFIG, ADDR_PHY_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_LOCAL_ODT_CONFIG, ADDR_PHY_LOCAL_ODT_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_RD_SLAVE, ADDR_PHY_RD_SLAVE_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_WR_SLAVE, ADDR_PHY_WR_SLAVE_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_IO_CELL_CONFIG, ADDR_PHY_IO_CELL_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_CFG_DONE, ADDR_SDRAM_CFG_DONE_DATA
+
+memif_shared_init:
+
+        /* Write the intialisation data into the picoArray */
+        configWriteLoadFile r0, r1, r2, r3, r4, memif_shared_init_data, 54
+
+/* Check to see if the mem-if Shared is ready yet? */
+memif_shared_init_poll:
+
+        configRead r0, r1, r2, PA_AEID_MEMIF, ADDR_SDRAM_STATUS
+
+        /* Has it timed out? */
+        TST     r0, #PA_CONFIG_TIMEOUT
+        BNE     memif_shared_init_poll
+
+        /* Has it configured? */
+        TST     r0, #0x01
+        BEQ     memif_shared_init_poll
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * register_initialisation
+ *
+ * Description: Initialise some CPU registers
+ *
+ * Note:
+ * Used to prevent X propagation if running this code in a simulation
+ *
+ *****************************************************************************/
+register_initialisation:
+
+        mov     r0, #0x00000000
+        mov     r1, #0x00000000
+        mov     r2, #0x00000000
+        mov     r3, #0x00000000
+        mov     r4, #0x00000000
+        mov     r5, #0x00000000
+        mov     r6, #0x00000000
+        mov     r7, #0x00000000
+        mov     r8, #0x00000000
+        mov     r9, #0x00000000
+        mov     r10,#0x00000000
+
+        /* Don't noodle with r11 (fp)
+                             r12 (ip)
+                             r13 (sp)
+                             r14 (lr)
+                             r15 (pc)
+           as this would cause big probs ! */
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * initialiseBootErrorPin
+ *
+ * Initialise the GPIO that is used as the Boot Error pin
+ *
+ *****************************************************************************/
+ initialiseBootErrorPin:
+
+        /* Get base address of the arm gpio block */
+        ldr     r0,=PC302_GPIO_BASE
+
+        /* Negate the Boot error pin (in the data register) */
+        ldr     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+        orr     r1,r1,#NEGATE_BOOT_ERROR_PIN
+        str     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+
+        /* Set up Boot Error pin to be an output */
+        ldr     r1,[r0, #GPIO_SW_PORT_C_DDR_REG_OFFSET]
+        orr     r1,r1,#BOOT_ERROR_PIN_IS_OUTPUT
+        str     r1,[r0, #GPIO_SW_PORT_C_DDR_REG_OFFSET]
+
+        /* Assert the GREEN LED pin in the data register */
+        ldr     r1,[r0, #GPIO_SW_PORT_A_DR_REG_OFFSET]
+        orr     r1,r1,#GREEN_LED_PIN_BIT
+        str     r1,[r0, #GPIO_SW_PORT_A_DR_REG_OFFSET]
+
+        /* Set up RED/GREEN LED pin to be an output */
+        ldr     r1,[r0, #GPIO_SW_PORT_A_DDR_REG_OFFSET]
+        orr     r1,r1,#GREEN_LED_PIN_BIT
+        str     r1,[r0, #GPIO_SW_PORT_A_DDR_REG_OFFSET]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * initialisePaiGpioPinMultiplexing
+ *
+ * Description: Ensure the ARM has control of the GPIO lines that are
+ *              multiplexed with the PAI interface.
+ *
+ *****************************************************************************/
+
+/* Data to set-up the PAI-ioCtrl, this is effectively a load file */
+#define PA_AEID_PAI          (0x0578)
+#define PAI_IOCTRL_ADDR      (0x0009)
+#define PAI_IOCTRL_USE_GPIO  (0x000F)
+
+#define LF_PA_AEID_PAI       (PA_AEID_PAI         | PA_CONFIG_AEID)
+#define LF_ADDR_PAI_IO_CTRL  (PAI_IOCTRL_ADDR     | PA_CONFIG_ADDR)
+#define LF_IO_CTRL_GPIO_DATA (PAI_IOCTRL_USE_GPIO | PA_CONFIG_WRITE)
+
+pai_gpio_mux_init_data:
+        .word   LF_PA_AEID_PAI, LF_CBFM_SLEEPREG_ADDR, PA_WRITE_ZERO_DATA
+        .word   LF_PA_AEID_PAI, LF_ADDR_PAI_IO_CTRL,   LF_IO_CTRL_GPIO_DATA
+
+initialisePaiGpioPinMultiplexing:
+
+        /* Write the intialisation data into the picoArray */
+        configWriteLoadFile r0, r1, r2, r3, r4, pai_gpio_mux_init_data, 6
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * assertBootError
+ *
+ * Assert the Boot Error pin. On the SVB302 this is used to illuminate an LED
+ *
+ *****************************************************************************/
+ .global assertBootError
+
+ assertBootError:
+
+        /* Get base address of the arm gpio block */
+        ldr     r0,=PC302_GPIO_BASE
+
+        /* Negate the GREEN LED pin in the data register */
+        ldr     r1,[r0, #GPIO_SW_PORT_A_DR_REG_OFFSET]
+        bic     r1,r1,#GREEN_LED_PIN_BIT
+        str     r1,[r0, #GPIO_SW_PORT_A_DR_REG_OFFSET]
+
+        /* Assert the Boot Error pin */
+        mov     r1, #ASSERT_BOOT_ERROR_PIN
+        str     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+       .end
diff -Naur pico_1.3.4/board/ipaccess/ip302ff/mt29f2g08aadwp.c ipa_1.3.4/board/ipaccess/ip302ff/mt29f2g08aadwp.c
--- pico_1.3.4/board/ipaccess/ip302ff/mt29f2g08aadwp.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip302ff/mt29f2g08aadwp.c	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,213 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file .mt29f2g08aadwp.c
+* \brief Support for the NAND Flash device fitted on PC7302 platform.
+*
+* Copyright (c) 2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+ 
+/*
+ * (C) Copyright 2009 SAGEM Communications
+ * (C) Copyright 2006 DENX Software Engineering
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CONFIG_CMD_NAND
+
+#include <asm/arch/pc302.h>
+#include <asm/arch/gpio.h>
+#include <nand.h>
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Define which gpio bits are used to control the NAND Flash
+ *
+ * Note: These pin definitions mean that we can only use NAND
+ *       Flash if we are running U-Boot from RAM and have NOT booted
+ *       the device from parallel NOR Flash.
+ *
+ * Note: These GPIO bits are all ARM GPIO bits.
+ */
+#define CLE   GPIO_BIT_4
+#define ALE   GPIO_BIT_3
+#define NCE   GPIO_BIT_2
+#define READY GPIO_BIT_1
+
+/*!
+ * \brief Hardware specific access to control-lines
+ * \param mtd, pointer to the mtd_info structure
+ * \param dat, data to write to the device
+ * \param ctrl, control data to set up the transaction
+ *
+ */
+static void mt29f2g08aadwp_cmd_ctrl(struct mtd_info *mtd,
+				    int dat,
+				    unsigned int ctrl)
+{
+    struct nand_chip *this = mtd->priv;
+
+    unsigned int odr;
+
+    /* Read the data register for port A,
+       Note: This will return the state of the pins programmed
+             to be outputs.
+    */
+    odr = *(volatile unsigned int *)(PC302_GPIO_BASE +
+				     GPIO_SW_PORT_A_DR_REG_OFFSET) & 0xFF;
+
+    if (ctrl & NAND_CTRL_CHANGE)
+    {
+        if (ctrl & NAND_NCE)
+        {
+            /* Assert the chip select */
+            odr &= ~NCE;
+            *(volatile unsigned int *)(PC302_GPIO_BASE +
+				       GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+
+	    if (ctrl & NAND_CLE)
+            {
+	        /* Assert CLE */
+                odr |= CLE;
+		*(volatile unsigned int *)(PC302_GPIO_BASE +
+					   GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+            }
+    	    else
+	    {
+                /* Negate CLE */
+                odr &= ~CLE;
+		*(volatile unsigned int *)(PC302_GPIO_BASE +
+					   GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+            }
+
+	    if (ctrl & NAND_ALE)
+	    {
+                /* Assert ALE */
+                odr |= ALE;
+		*(volatile unsigned int *)(PC302_GPIO_BASE +
+					   GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+            }
+	    else
+            {
+		/* Negate ALE */
+                odr &= ~ALE;
+		*(volatile unsigned int *)(PC302_GPIO_BASE +
+					   GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+            }
+        }
+        else
+        {
+	    /* Negate the chip select */
+            odr |= NCE;
+	    *(volatile unsigned int *)(PC302_GPIO_BASE +
+		     		       GPIO_SW_PORT_A_DR_REG_OFFSET) = odr;
+
+        }
+    }
+
+    /* If we have data to write, write it */
+    if (dat != NAND_CMD_NONE)
+    {
+	*(volatile unsigned char *)(this->IO_ADDR_W) = (unsigned char)dat;
+    }
+
+}
+
+/*!
+ * \brief Return the state of the NAND busy output
+ * \param mtd, pointer to the mtd_info structure
+ * \return 0 - nand busy
+ *         1 - nand ready
+ *
+ */
+static int mt29f2g08aadwp_dev_ready(struct mtd_info *mtd)
+{
+    unsigned int idr;
+
+    idr = *(volatile unsigned int *)(PC302_GPIO_BASE +
+			             GPIO_EXT_PORT_A_REG_OFFSET) & 0xFF;
+
+    return ((idr & READY) == READY)? 1: 0;
+}
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+    unsigned int ddr, dr;
+
+    /* Setup the gpio data direction register */
+    ddr = *(volatile unsigned int *)(PC302_GPIO_BASE +
+			             GPIO_SW_PORT_A_DDR_REG_OFFSET) & 0xFF;
+
+    /* The outputs */
+    ddr |= (CLE | ALE | NCE);
+
+    /* The inputs */
+    ddr &= ~READY;
+
+    *(volatile unsigned int *)(PC302_GPIO_BASE +
+	    		       GPIO_SW_PORT_A_DDR_REG_OFFSET) = ddr;
+
+    /* Setup a 'safe' initial value on the nand control pins */
+    dr = NCE;
+    dr &= ~(CLE | ALE);
+    *(volatile unsigned int *)(PC302_GPIO_BASE +
+		               GPIO_SW_PORT_A_DR_REG_OFFSET) = dr;
+
+    /* Populate some members of the nand structure */
+    nand->cmd_ctrl = mt29f2g08aadwp_cmd_ctrl;
+    nand->ecc.mode = NAND_ECC_SOFT;
+    nand->dev_ready = mt29f2g08aadwp_dev_ready;
+    nand->IO_ADDR_R = (void __iomem *)CONFIG_SYS_NAND_BASE;
+    nand->IO_ADDR_W = (void __iomem *)CONFIG_SYS_NAND_BASE;
+
+    return 0;
+}
+#endif /* CONFIG_CMD_NAND */
diff -Naur pico_1.3.4/board/ipaccess/ip302ff/pc7302.c ipa_1.3.4/board/ipaccess/ip302ff/pc7302.c
--- pico_1.3.4/board/ipaccess/ip302ff/pc7302.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip302ff/pc7302.c	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,198 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file pc7302.c
+* \brief Various useful functions for use on a PC7302 Platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+* Copyright (c) 2010 ip.access Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@ipaccess.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/utilities.h>
+#ifdef CONFIG_SOFT_I2C
+#include <asm/arch/pc302_gpio.h>
+#endif /* CONFIG_SOFT_I2C */
+
+/* Macros ------------------------------------------------------------------ */
+/*!
+ * Flag used to control whether or not the Die ID is displayed at boot time
+ */
+//#define DISPLAY_DIE_ID          (1)
+
+/* Constants --------------------------------------------------------------- */
+DECLARE_GLOBAL_DATA_PTR;
+
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ *
+ * Start timer #0 in free running mode
+ *
+ */
+static void pc302_timer_0_start(void);
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * show_boot_progress()
+ *
+ * Purpose: Indicate booting progress
+ *
+ * Note: see U-Boot README for a list of 'progress' values.
+ *
+ *****************************************************************************/
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+/*****************************************************************************
+ *
+ * board_init()
+ *
+ * Purpose: Hardware platform initialisation functions
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int board_init (void)
+{
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = 0x00000100;
+    gd->bd->bi_arch_number = MACH_TYPE_PC7302;
+    gd->flags = 0;
+
+    /* Enable the Instruction Cache */
+    icache_enable ();
+
+    /* Start a timer */
+    pc302_timer_0_start();
+
+#ifdef CONFIG_SOFT_I2C
+    /* Request the GPIOs for I2C */
+    pc302_gpio_init();
+
+    (void)pc302_gpio_request(PC302_GPIO_PIN_ARM_0, "I2C-SCL");
+    (void)pc302_gpio_request(PC302_GPIO_PIN_ARM_2, "I2C-SDA");
+
+    pc302_gpio_direction_output(PC302_GPIO_PIN_ARM_0, 1);
+    pc302_gpio_direction_input(PC302_GPIO_PIN_ARM_2);
+#endif /* CONFIG_SOFT_I2C */
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * checkboard()
+ *
+ * Purpose: Display some useful hardware platform information.
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int checkboard (void)
+{
+    unsigned int device_type, revision;
+    unsigned int die_id[4];
+
+    puts("Build: ip.access ip302ff \n");
+
+    /* What device are we running on ? */
+    puts("Device: ");
+
+    device_type = pc302_read_device_id();       /* Read the device Id */
+    revision = pc302_read_device_revision();    /* Read the revision code */
+    pc302_read_die_id_number(&die_id[0]);       /* Read the die id */
+
+    switch (device_type)
+    {
+        case PC302_DEVICE_ID:
+        {
+            printf("PC302 Rev %04d\n", revision);
+            break;
+        }
+        case PC312_DEVICE_ID:
+        {
+            printf("PC312 Rev %04d\n", revision);
+            break;
+        }
+        default:
+        {
+            printf("Unknown !\n");
+        }
+    }
+
+#if defined (DISPLAY_DIE_ID)
+    /* Ouput the die_id */
+    printf("Die Id: ");
+    printf("0x%08x\n", die_id[0]);
+    printf("        0x%08x\n", die_id[1]);
+    printf("        0x%08x\n", die_id[2]);
+    printf("        0x%08x\n", die_id[3]);
+#endif
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * misc_init_r()
+ *
+ * Purpose: Miscellaneous platform dependent initialisations
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int misc_init_r (void)
+{
+    /* Not used right now, function template left here as a place holder */
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * dram_init()
+ *
+ * Purpose: Initialize the DDR SDRAM info in the board data structure
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int dram_init (void)
+{
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+    return 0;
+}
+
+static void pc302_timer_0_start(void)
+{
+    /* Make sure timer #0 is disabled */
+    pc302_write_to_register((CFG_TIMERBASE + TIMERNCONTROLREGOFFSET(0)), 0);
+
+    /* Initialise the timer #0 to all 1's.  We do this  because we want to run
+       the timer in free running mode. */
+    pc302_write_to_register((CFG_TIMERBASE + TIMERNLOADCOUNTREGOFFSET(0)),
+                            0xFFFFFFFF);
+
+    /* Start timer #0 in free running mode */
+    pc302_write_to_register((CFG_TIMERBASE + TIMERNCONTROLREGOFFSET(0)),
+                            (TIMERINTERRUPTMASK | TIMERENABLE));
+}
diff -Naur pico_1.3.4/board/ipaccess/ip302ff/u-boot.lds ipa_1.3.4/board/ipaccess/ip302ff/u-boot.lds
--- pico_1.3.4/board/ipaccess/ip302ff/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/board/ipaccess/ip302ff/u-boot.lds	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,45 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file u-boot.lds
+* \brief Used during the build process.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+		cpu/arm926ejs/start.o (.text)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur pico_1.3.4/common/cmd_boot.c ipa_1.3.4/common/cmd_boot.c
--- pico_1.3.4/common/cmd_boot.c	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/common/cmd_boot.c	2011-04-26 11:53:24.000000000 +0100
@@ -71,8 +71,18 @@
 
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
 
+/*
+ * Wrapper round do_reset which clears bootcount if board is reset from the command line.
+ */
+int do_reset_cmd (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	bootcount_store (0);
+	do_reset(cmdtp, flag, argc, argv);
+        return 0;
+}
+
 U_BOOT_CMD(
-	reset, 1, 0,	do_reset,
-	"reset   - Perform RESET of the CPU\n",
+	reset, 1, 0,	do_reset_cmd,
+	"reset   - Clear bootcount, and perform RESET of the CPU\n",
 	NULL
 );
diff -Naur pico_1.3.4/common/cmd_bootm.c ipa_1.3.4/common/cmd_bootm.c
--- pico_1.3.4/common/cmd_bootm.c	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/common/cmd_bootm.c	2011-04-26 11:53:24.000000000 +0100
@@ -106,6 +106,9 @@
 #if defined(CONFIG_ARTOS) && defined(CONFIG_PPC)
 static boot_os_fn do_bootm_artos;
 #endif
+#if defined(CONFIG_VERIFY_KERNEL)
+extern int do_verify_kernel(ulong start, ulong end);
+#endif
 
 ulong load_addr = CFG_LOAD_ADDR;	/* Default Load Address */
 static bootm_headers_t images;		/* pointers to os/initrd/fdt images */
@@ -298,6 +301,14 @@
 	debug ("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load_start, load_end);
 	show_boot_progress (7);
 
+#ifdef CONFIG_VERIFY_KERNEL
+	if (do_verify_kernel(load_start, load_end))
+	{
+		show_boot_progress(-201);
+		return 1;
+	}
+#endif
+
 	if ((load_start < image_end) && (load_end > image_start)) {
 		debug ("image_start = 0x%lX, image_end = 0x%lx\n", image_start, image_end);
 		debug ("load_start = 0x%lx, load_end = 0x%lx\n", load_start, load_end);
diff -Naur pico_1.3.4/common/env_flash.c ipa_1.3.4/common/env_flash.c
--- pico_1.3.4/common/env_flash.c	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/common/env_flash.c	2011-04-26 11:53:24.000000000 +0100
@@ -83,6 +83,18 @@
 
 #define ACTIVE_FLAG   1
 #define OBSOLETE_FLAG 0
+
+#ifdef CONFIG_FALLBACK_TO_NONREDUND_ENV
+/* Backwards compatiblity for non-redundant environment */
+/* WARNING: This is hard-coded to the known old env format */
+#define OLD_ENV_SIZE    (0x10000 - 4)
+struct old_env {
+    unsigned long	crc;		/* CRC32 over data bytes	*/
+    unsigned char	data[OLD_ENV_SIZE]; /* Environment data		*/
+};
+static struct old_env *old_env = (struct old_env*)CFG_ENV_ADDR;
+#endif /* CONFIG_FALLBACK_TO_NONREDUND_ENV */
+
 #endif /* CFG_ENV_ADDR_REDUND */
 
 extern uchar default_environment[];
@@ -117,8 +129,17 @@
 		gd->env_addr  = addr2;
 		gd->env_valid = 1;
 	} else if (! crc1_ok && ! crc2_ok) {
-		gd->env_addr  = addr_default;
-		gd->env_valid = 0;
+#ifdef CONFIG_FALLBACK_TO_NONREDUND_ENV
+		/* Try to read non-redundant environment */
+		if (crc32(0, old_env->data, OLD_ENV_SIZE) == old_env->crc) {
+			gd->env_addr  = (ulong)&(old_env->data);
+			gd->env_valid = 3;
+		} else
+#endif /* CONFIG_FALLBACK_TO_NONREDUND_ENV */
+        {
+            gd->env_addr  = addr_default;
+            gd->env_valid = 0;
+        }
 	} else if (flag1 == ACTIVE_FLAG && flag2 == OBSOLETE_FLAG) {
 		gd->env_addr  = addr1;
 		gd->env_valid = 1;
@@ -267,7 +288,7 @@
 	int	len, rc;
 	ulong	end_addr;
 	ulong	flash_sect_addr;
-#if defined(CFG_ENV_SECT_SIZE) && (CFG_ENV_SECT_SIZE > CFG_ENV_SIZE)
+#if defined(CFG_ENV_SECT_SIZE) && (CFG_ENV_SECT_SIZE > CFG_ENV_SIZE)  && defined(IPA_NEVER_DEFINED) 
 	ulong	flash_offset;
 	uchar	env_buffer[CFG_ENV_SECT_SIZE];
 #else
@@ -275,8 +296,9 @@
 #endif	/* CFG_ENV_SECT_SIZE */
 	int rcode = 0;
 
-#if defined(CFG_ENV_SECT_SIZE) && (CFG_ENV_SECT_SIZE > CFG_ENV_SIZE)
+#if defined(CFG_ENV_SECT_SIZE) && (CFG_ENV_SECT_SIZE > CFG_ENV_SIZE)  && defined(IPA_NEVER_DEFINED) 
 
+    puts("\nTesting...\n");
 	flash_offset    = ((ulong)flash_addr) & (CFG_ENV_SECT_SIZE-1);
 	flash_sect_addr = ((ulong)flash_addr) & ~(CFG_ENV_SECT_SIZE-1);
 
@@ -309,15 +331,19 @@
 	debug ("Protect off %08lX ... %08lX\n",
 		(ulong)flash_sect_addr, end_addr);
 
-	if (flash_sect_protect (0, flash_sect_addr, end_addr))
+    puts("Before flash portect\n");
+
+/*	if (flash_sect_protect (0, flash_sect_addr, end_addr))*/
+	if (flash_sect_protect (0, flash_sect_addr, flash_sect_addr + CFG_ENV_SECT_SIZE -1))
 		return 1;
 
-	puts ("Erasing Flash...");
-	if (flash_sect_erase (flash_sect_addr, end_addr))
+	puts ("Erasing Flash...\n");
+/*	if (flash_sect_erase (flash_sect_addr, end_addr)) */
+    if (flash_sect_erase (flash_sect_addr, flash_sect_addr + CFG_ENV_SECT_SIZE -1))
 		return 1;
 
-	puts ("Writing to Flash... ");
-	rc = flash_write((char *)env_buffer, flash_sect_addr, len);
+	puts ("Writing to Flash...\n");
+	rc = flash_write((char *)env_buffer, flash_sect_addr, len); 
 	if (rc != 0) {
 		flash_perror (rc);
 		rcode = 1;
@@ -326,7 +352,8 @@
 	}
 
 	/* try to re-protect */
-	(void) flash_sect_protect (1, flash_sect_addr, end_addr);
+/*	(void) flash_sect_protect (1, flash_sect_addr, end_addr); */
+    (void) flash_sect_protect (1, flash_sect_addr, flash_sect_addr + CFG_ENV_SECT_SIZE -1);
 	return rcode;
 }
 
@@ -338,6 +365,24 @@
 {
 #if !defined(ENV_IS_EMBEDDED) || defined(CFG_ENV_ADDR_REDUND)
 #ifdef CFG_ENV_ADDR_REDUND
+
+#ifdef CONFIG_FALLBACK_TO_NONREDUND_ENV
+	/* Fix up environment from old format */
+	if (gd->env_valid == 3) {
+		int copylen;
+		puts("Converting old environment\n");
+		copylen = OLD_ENV_SIZE;
+		if (copylen > ENV_SIZE) copylen = ENV_SIZE;
+		memset (env_ptr, 0, sizeof(env_t));
+		memcpy (env_ptr->data, old_env->data, copylen);
+		env_ptr->flags = 0xFF;
+		env_crc_update ();
+		gd->env_valid = 1;
+		return;
+	}
+#endif /* CONFIG_FALLBACK_TO_NONREDUND_ENV */
+
+
 	if (gd->env_addr != (ulong)&(flash_addr->data)) {
 		env_t * etmp = flash_addr;
 		ulong ltmp = end_addr;
diff -Naur pico_1.3.4/common/soft_i2c.c ipa_1.3.4/common/soft_i2c.c
--- pico_1.3.4/common/soft_i2c.c	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/common/soft_i2c.c	2011-04-26 11:53:24.000000000 +0100
@@ -39,6 +39,9 @@
 #ifdef CONFIG_LPC2292
 #include <asm/arch/hardware.h>
 #endif
+#ifdef CONFIG_PICOCHIP_PC302
+#include <asm/arch/pc302_gpio.h>
+#endif
 #include <i2c.h>
 
 #if defined(CONFIG_SOFT_I2C)
diff -Naur pico_1.3.4/cpu/arm926ejs/config.mk ipa_1.3.4/cpu/arm926ejs/config.mk
--- pico_1.3.4/cpu/arm926ejs/config.mk	2011-04-26 11:53:20.000000000 +0100
+++ ipa_1.3.4/cpu/arm926ejs/config.mk	2011-04-26 11:53:24.000000000 +0100
@@ -37,5 +37,5 @@
 # Supply options according to compiler version
 #
 # =========================================================================
-PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)
+PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32)
 PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
diff -Naur pico_1.3.4/cpu/arm926ejs/pc302/emac.c ipa_1.3.4/cpu/arm926ejs/pc302/emac.c
--- pico_1.3.4/cpu/arm926ejs/pc302/emac.c	2011-04-26 11:53:20.000000000 +0100
+++ ipa_1.3.4/cpu/arm926ejs/pc302/emac.c	2011-04-26 11:53:24.000000000 +0100
@@ -22,6 +22,9 @@
 
 #include <malloc.h>
 #include <net.h>
+#ifdef CONFIG_MICREL_SWITCH
+#include <i2c.h>
+#endif /* CONFIG_MICREL_SWITCH */
 #include <asm/io.h>
 #include <asm/arch/pc302.h>
 #include <asm/arch/emac.h>
@@ -80,6 +83,23 @@
  */
 #define PHY_AUTO_NEG_ADVERT_VALUE   (0x0181)
 
+
+#define MICREL_PORT1_CTRL12_REG 0x1C
+#define MICREL_PORT2_CTRL12_REG 0x2C
+#define MICREL_PORT2_CTRL13_REG 0x2D
+
+#define MICREL_PORT1_STATUS_REG 0x1E
+#define MICREL_PORT2_STATUS_REG 0x2E
+#define MP1S_AN_DONE            (1 << 6)
+#define MP1S_LSTATUS            (1 << 5)
+#define MP1S_LPA_PAUSE_CAP      (1 << 4)
+#define MP1S_LPA_100FULL        (1 << 3)
+#define MP1S_LPA_100HALF        (1 << 2)
+#define MP1S_LPA_10FULL         (1 << 1)
+#define MP1S_LPA_10HALF         (1 << 0)
+
+#define MC13_POWER_DOWN_PHY     8
+
 /* Constants --------------------------------------------------------------- */
 
 /* !
@@ -166,7 +186,11 @@
  * \param dev Pointer to the eth_device structure
  *
  */
+#ifndef CONFIG_MICREL_SWITCH
 static void emac_phy_get_link_speed(struct eth_device *dev);
+#else
+/* not used for micrel_phy */
+#endif /* CONFIG_MICREL_SWITCH */
 
 /*!
  *
@@ -175,7 +199,11 @@
  * \param dev Pointer to the eth_device structure
  *
  */
+#ifndef CONFIG_MICREL_SWITCH
 static void emac_phy_get_link_status(struct eth_device *dev);
+#else
+static void micrel_phy_get_link_status(struct eth_device *dev);
+#endif /* CONFIG_MICREL_SWITCH */
 
 /*!
  *
@@ -309,9 +337,6 @@
 static int emac_init_phy(struct eth_device *dev)
 {
     struct emac_priv *priv = dev->priv;
-    unsigned int network_control_register = 0;
-    unsigned int network_config_register = 0;
-    unsigned short phy_control = 0;
 
     /* Initialise the phy status parameters in the private data structure */
     priv->auto_negotiation = ~(EMAC_PHY_AUTO_NEG_COMPLETE);
@@ -319,66 +344,87 @@
     priv->speed = EMAC_PHY_SPEED_10;
     priv->duplex = EMAC_PHY_DUPLEX_HALF;
 
-    /* Set phy management MDC Clock to 200 MHz (pclk) / 96 */
-    network_config_register = EMAC_READ(EMAC_NETWORK_CFG_REG_OFFSET);
-    network_config_register &= EMAC_MDC_CLOCK_DIV_MASK;
-    network_config_register |= EMAC_MDC_CLOCK_DIV_96;
-    EMAC_WRITE(network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
-
-    /* Enable phy management */
-    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
-    network_control_register |= EMAC_MDIO_ENABLE;
-    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
-
-    /* If we are running on PC302 Rev D silicon and we are using a
-     * Reduced MII (RMII) connected Ethernet Phy then we need the
-     * link speed to be 100 mbps.
+#ifndef CONFIG_MICREL_SWITCH
+    /* 
+     * MII PHY i/f
      */
-    if ((pc302_read_device_revision() == PC302_REV_D) &&
-        pc302_get_rmii_enabled())
     {
-        /* Are we already set for 100 mpbs ? */
-        emac_phy_get_link_speed(dev);
-        if (priv->speed == EMAC_PHY_SPEED_100)
+        unsigned int network_control_register = 0;
+        unsigned int network_config_register = 0;
+        unsigned short phy_control = 0;
+
+        /* Set phy management MDC Clock to 200 MHz (pclk) / 96 */
+        network_config_register = EMAC_READ(EMAC_NETWORK_CFG_REG_OFFSET);
+        network_config_register &= EMAC_MDC_CLOCK_DIV_MASK;
+        network_config_register |= EMAC_MDC_CLOCK_DIV_96;
+        EMAC_WRITE(network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
+
+        /* Enable phy management */
+        network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
+        network_control_register |= EMAC_MDIO_ENABLE;
+        EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+        /* If we are running on PC302 Rev D silicon and we are using a
+         * Reduced MII (RMII) connected Ethernet Phy then we need the
+         * link speed to be 100 mbps.
+         */
+        if ((pc302_read_device_revision() == PC302_REV_D) &&
+            pc302_get_rmii_enabled())
         {
-            /* No need to do anything */
+            /* Are we already set for 100 mpbs ? */
+            emac_phy_get_link_speed(dev);
+            if (priv->speed == EMAC_PHY_SPEED_100)
+            {
+                /* No need to do anything */
+            }
+            else
+            {
+                /* Setup the phy auto-negotiation advertisment register */
+                emac_mii_write(CONFIG_PHY_ADDR, PHY_ANAR,
+                               PHY_AUTO_NEG_ADVERT_VALUE);
+
+                /* Re-start auto-negotiation */
+                emac_mii_write(CONFIG_PHY_ADDR, PHY_BMCR,
+                               (PHY_BMCR_AUTO_NEG_ENABLE | PHY_BMCR_RESTART_NEG));
+
+                /* Allow some time for the auto-negotiation process to start */
+                udelay(100);
+            }
+        }
+
+        emac_phy_get_link_status(dev);
+
+        if (priv->link == EMAC_PHY_LINK_DOWN)
+        {
+            /* Oops, no valid link established, time to bail out */
+            return (1);
         }
         else
         {
-            /* Setup the phy auto-negotiation advertisment register */
-            emac_mii_write(CONFIG_PHY_ADDR, PHY_ANAR,
-                           PHY_AUTO_NEG_ADVERT_VALUE);
+            /* We have a valid link established */
 
-            /* Re-start auto-negotiation */
-            emac_mii_write(CONFIG_PHY_ADDR, PHY_BMCR,
-                           (PHY_BMCR_AUTO_NEG_ENABLE | PHY_BMCR_RESTART_NEG));
+            /* Obtain the link speed */
+            emac_phy_get_link_speed(dev);
 
-            /* Allow some time for the auto-negotiation process to start */
-            udelay(100);
+            /* Obtain the link duplex setting */
+            phy_control = emac_mii_read(CONFIG_PHY_ADDR, PHY_BMCR);
+            if (phy_control & PHY_BMCR_FULL_DUPLEX)
+            {
+                priv->duplex = EMAC_PHY_DUPLEX_FULL;
+            }
         }
     }
-
-    emac_phy_get_link_status(dev);
-
+#else /* CONFIG_MICREL_SWITCH */
+    /* 
+     * I2C PHY i/f
+     */
+    micrel_phy_get_link_status(dev);
     if (priv->link == EMAC_PHY_LINK_DOWN)
     {
         /* Oops, no valid link established, time to bail out */
         return (1);
     }
-    else
-    {
-        /* We have a valid link established */
-
-        /* Obtain the link speed */
-        emac_phy_get_link_speed(dev);
-
-        /* Obtain the link duplex setting */
-        phy_control = emac_mii_read(CONFIG_PHY_ADDR, PHY_BMCR);
-        if (phy_control & PHY_BMCR_FULL_DUPLEX)
-        {
-            priv->duplex = EMAC_PHY_DUPLEX_FULL;
-        }
-    }
+#endif /* CONFIG_MICREL_SWITCH */
 
     /* Report the phy setup */
     if (priv->speed == EMAC_PHY_SPEED_100)
@@ -402,6 +448,9 @@
     return(0);
 }
 
+
+#ifndef CONFIG_MICREL_SWITCH
+
 static void emac_phy_get_link_speed(struct eth_device *dev)
 {
     struct emac_priv *priv = dev->priv;
@@ -521,6 +570,62 @@
     }
 }
 
+#else /* CONFIG_MICREL_SWITCH */
+
+static void micrel_phy_get_link_status(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int timebase = 0;
+    int lpa;
+
+    printf("%s: polling for Auto-Negotiation complete\n", dev->name);
+    timebase = get_timer(0);
+    do
+    {
+        /* Read link status */
+        lpa = i2c_reg_read(CFG_MICREL_SWITCH_ADDR, MICREL_PORT1_STATUS_REG);
+        if (lpa & MP1S_AN_DONE)
+        {
+            /* We have a successful auto-negotiation */
+            printf("%s: Auto-Negotiation complete\n", dev->name);
+            priv->auto_negotiation = EMAC_PHY_AUTO_NEG_COMPLETE;
+            break;
+        }
+    }
+    while (get_timer(timebase) < EMAC_PHY_TIMEOUT);
+
+    if ((lpa & MP1S_LSTATUS) == 0)
+    {
+        /* We do not have a valid link established */
+        printf("%s: Link down !\n", dev->name);
+        priv->link = EMAC_PHY_LINK_DOWN;
+    }
+    else
+    {
+        /* We have a valid link established */
+        printf("%s: Link up\n", dev->name);
+        priv->link = EMAC_PHY_LINK_UP;
+
+        /* Report back link speed etc */
+        priv->speed = EMAC_PHY_SPEED_10;
+        priv->duplex = EMAC_PHY_DUPLEX_HALF;
+        if (lpa & (MP1S_LPA_100FULL | MP1S_LPA_100HALF)) {
+            priv->speed = EMAC_PHY_SPEED_100;
+
+            if (lpa & MP1S_LPA_100FULL) {
+                priv->duplex = EMAC_PHY_DUPLEX_FULL;
+            }
+        } else {
+            if (lpa & MP1S_LPA_10FULL) {
+                priv->duplex = EMAC_PHY_DUPLEX_FULL;
+            }
+        }
+    }
+
+} /* micrel_phy_get_link_status() */
+
+#endif /* CONFIG_MICREL_SWITCH */
+
 static void emac_set_mac_addr(struct eth_device *dev)
 {
     unsigned int mac_addr_bottom = 0;
@@ -777,6 +882,11 @@
     struct eth_device *dev = NULL;
     struct emac_priv *priv = NULL;
 
+#ifdef CONFIG_MICREL_SWITCH
+    /* Disable the BTS port on the switch */
+    i2c_reg_write(CFG_MICREL_SWITCH_ADDR, MICREL_PORT2_CTRL13_REG, MC13_POWER_DOWN_PHY);
+#endif /*  CONFIG_MICREL_SWITCH */
+
     /* Create some storage for useful structures */
     dev = (struct eth_device *) malloc(sizeof (*dev));
     priv = (struct emac_priv *) malloc(sizeof (*priv));
diff -Naur pico_1.3.4/cpu/arm926ejs/pc302/pc302_gpio.c ipa_1.3.4/cpu/arm926ejs/pc302/pc302_gpio.c
--- pico_1.3.4/cpu/arm926ejs/pc302/pc302_gpio.c	2011-04-26 11:53:20.000000000 +0100
+++ ipa_1.3.4/cpu/arm926ejs/pc302/pc302_gpio.c	2011-04-26 11:53:24.000000000 +0100
@@ -1212,6 +1212,26 @@
 }
 
 int
+pc302_gpio_set_direction( unsigned gpio,
+                          int dir )
+{
+    struct pc302gpio_pin_allocation *pin;
+    int ret;
+
+    pin = pc302gpio_find_pin( gpio );
+
+    ret = -ENXIO;
+    if ( !pin )
+        goto out;
+
+    pin->is_input = dir;
+    ret = pc302gpio_set_direction( pin, dir );
+
+out:
+    return ret;
+}
+
+int
 pc302_gpio_set_value( unsigned gpio,
                       int value )
 {
diff -Naur pico_1.3.4/drivers/mtd/cfi_flash.c ipa_1.3.4/drivers/mtd/cfi_flash.c
--- pico_1.3.4/drivers/mtd/cfi_flash.c	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/drivers/mtd/cfi_flash.c	2011-04-26 11:53:24.000000000 +0100
@@ -1870,7 +1870,19 @@
 		info->size = 1 << qry.dev_size;
 		/* multiply the size by the number of chips */
 		info->size *= size_ratio;
-		info->buffer_size = 1 << le16_to_cpu(qry.max_buf_write_size);
+		/* The write buffer size is limited by the chip width as you have to write the number
+		   words/bytes you are going to program as part of the programming sequence.
+		   For example, if the chip width is 8 bits then maximum buffer size is 256 bytes.
+		   See data sheet for Numonyx M29EW for an example of the issue.
+		*/
+		if ( (info->chipwidth * 8) < le16_to_cpu(qry.max_buf_write_size))
+		{
+			info->buffer_size = 1 << (info->chipwidth * 8);
+		}
+		else
+		{
+			info->buffer_size = 1 << le16_to_cpu(qry.max_buf_write_size);
+		}
 		tmp = 1 << qry.block_erase_timeout_typ;
 		info->erase_blk_tout = tmp *
 			(1 << qry.block_erase_timeout_max);
diff -Naur pico_1.3.4/examples/Makefile ipa_1.3.4/examples/Makefile
--- pico_1.3.4/examples/Makefile	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/examples/Makefile	2011-04-26 11:53:24.000000000 +0100
@@ -33,9 +33,13 @@
 ifeq ($(BOARD),omap2420h4)
 LOAD_ADDR = 0x80300000
 else
+ifeq ($(BOARD),ip302ff)
+LOAD_ADDR = 0x43E30000
+else
 LOAD_ADDR = 0xc100000
 endif
 endif
+endif
 
 ifeq ($(ARCH),mips)
 LOAD_ADDR = 0x80200000 -T mips.lds
diff -Naur pico_1.3.4/include/asm-arm/arch-pc20x/ebi.h ipa_1.3.4/include/asm-arm/arch-pc20x/ebi.h
--- pico_1.3.4/include/asm-arm/arch-pc20x/ebi.h	2011-04-26 11:53:20.000000000 +0100
+++ ipa_1.3.4/include/asm-arm/arch-pc20x/ebi.h	2011-04-26 11:53:24.000000000 +0100
@@ -80,8 +80,18 @@
 #define SyncFlashControlRegOffset       0xB4
 #define SyncFlashTimRegOffset           0xB8
 
-/* #define StaticMemTimSet0Value           0x10C74F4F */
-#define StaticMemTimSet0Value           0x10C7174F 
+/* EBI bus speeds for Flash access - depends on clock speed of board variant */
+#if defined(IPA_BOARD_TYPE_XB) || defined(IPA_BOARD_TYPE_XCMINUS)
+#   define StaticMemTimSet0Value           0x10C7174F 
+
+#elif defined(IPA_BOARD_TYPE_XBPLUS) || defined(IPA_BOARD_TYPE_XC)
+#   define StaticMemTimSet0Value           0x10F7279C 
+
+#else
+#   error IPA_BOARD_TYPE not defined so EBI bus config not known!
+#   define StaticMemTimSet0Value           0x10C7174F 
+#endif
+
 
 #define WriteProtectAllDisable          0x0000000E
 
diff -Naur pico_1.3.4/include/asm-arm/arch-pc302/ebi.h ipa_1.3.4/include/asm-arm/arch-pc302/ebi.h
--- pico_1.3.4/include/asm-arm/arch-pc302/ebi.h	2011-04-26 11:53:20.000000000 +0100
+++ ipa_1.3.4/include/asm-arm/arch-pc302/ebi.h	2011-04-26 11:55:41.000000000 +0100
@@ -190,4 +190,3 @@
 #endif  /* __cplusplus */
 
 #endif /* PC302_EBI_H */
-/
diff -Naur pico_1.3.4/include/asm-arm/arch-pc302/mem_shd.h ipa_1.3.4/include/asm-arm/arch-pc302/mem_shd.h
--- pico_1.3.4/include/asm-arm/arch-pc302/mem_shd.h	2011-04-26 11:53:20.000000000 +0100
+++ ipa_1.3.4/include/asm-arm/arch-pc302/mem_shd.h	2011-04-26 11:53:24.000000000 +0100
@@ -219,6 +219,7 @@
 #define MRS_DDR2_CAS_IDX                (4)
 #define MRS_DDR2_WR_IDX                 (9)
 
+#define EMRS_DRIVE_STRENGTH_IDX         (1)
 #define EMRS_ODT_LOW_BIT_IDX            (2)
 #define EMRS_ODT_HIGH_BIT_IDX           (6)
 #define EMRS_DQSN_DISABLE_IDX           (10)
@@ -320,10 +321,13 @@
 
 #define SDRAM_ODT_75_OHM_LO             (0x1)
 #define SDRAM_ODT_75_OHM_HI             (0x0)
+#define SDRAM_REDUCED_DRIVE             (0x1)
+#define SDRAM_FULL_DRIVE                (0x0)
 
 #define ADDR_SDRAM_EMRS_DATA            (0x00000000 | PA_CONFIG_WRITE | \
                                         (SDRAM_ODT_75_OHM_LO        << EMRS_ODT_LOW_BIT_IDX) | \
                                         (SDRAM_ODT_75_OHM_HI        << EMRS_ODT_HIGH_BIT_IDX) | \
+                                        (SDRAM_REDUCED_DRIVE        << EMRS_DRIVE_STRENGTH_IDX) | \
                                         (DDR2_DQSN_DISABLE << EMRS_DQSN_DISABLE_IDX))
 
 #define ADDR_PHY_CONFIG_DATA            (0x00000000 | PA_CONFIG_WRITE | \
diff -Naur pico_1.3.4/include/asm-arm/arch-pc302/pc302_gpio.h ipa_1.3.4/include/asm-arm/arch-pc302/pc302_gpio.h
--- pico_1.3.4/include/asm-arm/arch-pc302/pc302_gpio.h	2011-04-26 11:53:20.000000000 +0100
+++ ipa_1.3.4/include/asm-arm/arch-pc302/pc302_gpio.h	2011-04-26 11:53:24.000000000 +0100
@@ -7,6 +7,7 @@
  * \brief Definitions use with the PC302 gpio library.
  *
  * Copyright (c) 2009 picoChip Designs Ltd
+ * Copyright (c) 2010 ip.access Ltd
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -131,6 +132,16 @@
                              int value );
 
 /**
+ * Set the direction of a GPIO pin.
+ *
+ * \param gpio The number of the pin to set the value of.
+ * \param value 0 for output, 1 for input
+ */
+int
+pc302_gpio_set_direction( unsigned gpio,
+                          int dir );
+
+/**
  * Set the value of a GPIO pin.
  *
  * \param gpio The number of the pin to set the value of.
diff -Naur pico_1.3.4/include/configs/ipaccess217.h ipa_1.3.4/include/configs/ipaccess217.h
--- pico_1.3.4/include/configs/ipaccess217.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/include/configs/ipaccess217.h	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,46 @@
+/*!
+* \file ipaccess217.h
+* \brief Configuration file for U-Boot on the Nano-8 platform.
+*
+* Copyright (c) 2010 ip.access Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@ipaccess.com
+*/
+
+#ifndef __CONFIG_H
+
+/* Include common ip302ff config */
+#include <configs/ipaccessip302ff.h>
+
+
+/*-----------------------------------------------------------------------
+ * I2C configuration
+ */
+#define	CONFIG_SOFT_I2C			/* Software I2C support enabled	*/
+
+/* Dummy values required for generic code */
+#define CFG_I2C_SPEED		50000
+#define CFG_I2C_SLAVE		0x7F
+
+/*
+ * Software (bit-bang) I2C driver configuration
+ */
+#define I2C_ACTIVE	pc302_gpio_set_direction(PC302_GPIO_PIN_ARM_2, 0)
+#define I2C_TRISTATE	pc302_gpio_set_direction(PC302_GPIO_PIN_ARM_2, 1)
+#define I2C_READ	pc302_gpio_get_value(PC302_GPIO_PIN_ARM_2)
+#define I2C_SDA(bit)	pc302_gpio_set_value(PC302_GPIO_PIN_ARM_2, bit ? 1 : 0)
+#define I2C_SCL(bit)	pc302_gpio_set_value(PC302_GPIO_PIN_ARM_0, bit ? 1 : 0)
+#define I2C_DELAY	udelay(5)	/* fairly conservative */
+
+#define CONFIG_CMD_I2C
+
+#define CONFIG_MICREL_SWITCH
+#define CFG_MICREL_SWITCH_ADDR	0x5F
+
+
+#endif /* __CONFIG_H */
+
diff -Naur pico_1.3.4/include/configs/ipaccessip202ff.h ipa_1.3.4/include/configs/ipaccessip202ff.h
--- pico_1.3.4/include/configs/ipaccessip202ff.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/include/configs/ipaccessip202ff.h	2011-06-24 11:21:46.000000000 +0100
@@ -0,0 +1,434 @@
+/*
+ * Copyright(C) 2006 picoChip(R) Designs Ltd.
+ * Copyright(C) 2007-2009 ip.access Ltd
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <ipa_config.h>
+
+#include <asm/arch/pc20x.h>
+#include <asm/arch/sizes.h>
+#include <asm/arch/uart.h>
+
+/*-----------------------------------------------------------------------------
+ * Platform Identification Stuff
+ */
+#define PICOCHIP "picochip"
+
+/* Which hardware platform I am destined for */
+#define PICOCHIP_PLATFORM "cpe20x"
+
+/* Specific version of this build */
+#ifndef PICOCHIP_PLATFORM_VERSION
+#define PICOCHIP_PLATFORM_VERSION "3.2.4-2BanksDDR"
+#endif /* PICOCHIP_PLATFORM_VERSION */
+
+#if 0
+#define CONFIG_IDENT_STRING " "PICOCHIP"-"PICOCHIP_PLATFORM_VERSION \
+                            "-"PICOCHIP_PLATFORM
+#endif
+
+/*-----------------------------------------------------------------------------
+ * Board Variant definitions
+ */
+#if defined(IPA_BOARD_TYPE_XC)
+#   define CONFIG_PICOCHIP_PC20X_REV_B                 /* Define if running on Rev B Si */
+#   define PC20X_AHB_CLOCK_FREQ        140000000       /* ARM Sub-system peripherals are clocked at 140 MHz Rev B Si */
+#   define CFG_MAX_FLASH_SECT          1024            /* 128MB FLASH */
+#   define CONFIG_PC20X_2_DDR_RAM_BANKS                /* #define this if you want to run with 2 Banks DDR Ram */                                                      
+#else
+#   error No valid IPA_BOARD_TYPE specified!
+#endif
+
+
+/*-----------------------------------------------------------------------------
+ * High Level Configuration Options
+ */
+/* Running on picoChip PC20x Si */
+#define CONFIG_PICOCHIP_PC20X
+
+/* Running on a picoChip CPE20x platform */
+#define CONFIG_PICOCHIP_CPE20X
+
+/* Define this if running code in PC20X rtl simulation land */
+#undef CONFIG_PC20X_SIMULATION
+
+/* Bootable Flash memory has to live here (/ebi_decode0) */
+#define PC20X_BOOTABLE_FLASH_BASE   (0x20000000)
+
+/* Base address of the onchip SRAM */
+#define PC20X_ONCHIP_SRAM_BASE      (0x10000000)
+#define PC20X_ONCHIP_SRAM_SIZE      (SZ_128K)
+
+/* Don't use Interrupts */
+#undef CONFIG_USE_IRQ
+
+/* Onchip timer runs at this frequency */
+#define CFG_HZ			    (PC20X_AHB_CLOCK_FREQ)
+#define CONFIG_SYS_HZ               (CFG_HZ)
+
+/* Display board info */
+#define CONFIG_DISPLAY_BOARDINFO    (1)
+
+/* Are we are going to be running from RAM ? */
+#ifdef CONFIG_RUN_FROM_RAM
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SKIP_RELOCATE_UBOOT
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------
+ * Stack Sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(SZ_256K)	    /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_1K)	            /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_1K)	            /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+
+/*-----------------------------------------------------------------------------
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		(SZ_256K)
+
+ /* Size in bytes reserved for initial data */
+#define CFG_GBL_DATA_SIZE	(SZ_256)
+
+/*-----------------------------------------------------------------------------
+ * Linux Kernel Stuff
+ */
+/* Allow passing of command line args (bootargs) to the linux kernel*/
+#define CONFIG_CMDLINE_TAG
+
+/*-----------------------------------------------------------------------------
+ * DDR2 RAM Memory Map
+ */
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+#define CONFIG_NR_DRAM_BANKS    (4)                 /* We have 4 RAM banks */
+#define PHYS_SDRAM_1		(0x00000000)
+#define PHYS_SDRAM_1_SIZE	(SZ_32M)            /* 32 Mbytes */
+#define PHYS_SDRAM_2		(0x04000000)
+#define PHYS_SDRAM_2_SIZE	(SZ_32M)            /* 32 Mbytes */
+#define PHYS_SDRAM_3		(0x08000000)
+#define PHYS_SDRAM_3_SIZE	(SZ_32M)            /* 32 Mbytes */
+#define PHYS_SDRAM_4		(0x0C000000)
+#define PHYS_SDRAM_4_SIZE	(SZ_32M)            /* 32 Mbytes */
+
+#else   /* We want a 2 DDR Bank setup then */
+
+#define CONFIG_NR_DRAM_BANKS    (2)                 /* We have 2 RAM banks */
+#define PHYS_SDRAM_1		(0x00000000)
+#define PHYS_SDRAM_1_SIZE	(SZ_32M)            /* 32 Mbytes */
+#define PHYS_SDRAM_2		(0x04000000)
+#define PHYS_SDRAM_2_SIZE	(SZ_32M)            /* 32 Mbytes */
+
+#endif /* CONFIG_PC20X_2_DDR_RAM_BANKS */
+
+/*-----------------------------------------------------------------------------
+ * Flash Memory Stuff
+ */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Define Flash memory sector size
+  128 kbytes (1 off Flash devices with 128K sector size) */
+#define FLASH_SECTOR_SIZE	(SZ_128K)
+
+#define CFG_FLASH_CFI
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_EMPTY_INFO
+
+/* Provide a much improved performance when writing to the Flash */
+#define CFG_FLASH_USE_BUFFER_WRITE
+
+#define CFG_FLASH_BASE		(PC20X_BOOTABLE_FLASH_BASE)
+
+/* Maximum number of memory banks */
+#define CFG_MAX_FLASH_BANKS	(1)
+
+/* flash layout for 64Mb+ boards */
+#define MTDPARTS_64M  "256K(uBoot),256K(env),2M(kernel1),2M(kernel2),3584K(config),27M(FS1),27M(FS2)," \
+                      "256K(oem_divert1),256K(oem_divert2),256K(oem_data1),256K(oem_data2)," \
+                      "256K(oem_lib1),256K(oem_lib2),256K(resv),256K(ipa_calib)"
+
+#ifdef IPA_BOARD_TYPE_XC
+#define MTDPARTS_DEFAULT MTDPARTS_64M
+#endif
+
+/* Timeouts for Flash Erasing and writing */
+#define CFG_FLASH_ERASE_TOUT	(2*CFG_HZ)
+#define CFG_FLASH_WRITE_TOUT	(2*CFG_HZ)
+
+/* U-Boot occupies 2 Flash sectors */
+#define CFG_MONITOR_LEN		(2*FLASH_SECTOR_SIZE)
+
+/* U-Boot lives in the bottom of the Flash memory */
+#define CFG_MONITOR_BASE        (CFG_FLASH_BASE)
+
+#else
+
+/* No flash memory in the system */
+#define CFG_NO_FLASH
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Environment Stuff
+ */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Environment variables stored in Flash memory */
+#define CFG_ENV_IS_IN_FLASH     (1)
+#define CFG_ENV_ADDR            (PC20X_BOOTABLE_FLASH_BASE+(2*FLASH_SECTOR_SIZE))
+
+/* One flash sector for environment info */
+#define CFG_ENV_SECT_SIZE       (FLASH_SECTOR_SIZE)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+/* Defining CFG_ENV_ADDR_REDUND enables redundant environment */
+#define CFG_ENV_ADDR_REDUND     (CFG_ENV_ADDR + FLASH_SECTOR_SIZE)
+
+#define CONFIG_FALLBACK_TO_NONREDUND_ENV        /* Enable for upgrades from old env format */
+
+#else
+
+/* Just use the default environment in the image */
+#define CFG_ENV_IS_NOWHERE
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------------
+ * Timer Stuff
+ */
+#define CFG_TIMERBASE           (PC20X_TIMER_BASE)
+
+/*-----------------------------------------------------------------------------
+ * Ethernet Stuff
+ */
+#define CFG_DW_EMAC
+#define CONFIG_PHY_ADDR         (0)
+#define CONFIG_NET_MULTI
+
+/*-----------------------------------------------------------------------------
+ * Serial Port Stuff
+ */
+#define CFG_DW_APB_UART
+
+/* Baud rate generators clock with a 3.6864 MHz clock */
+#define CONFIG_DW_APB_UART_CLOCK    (3686400)
+
+/* Console on Uart #0 */
+#define CONFIG_CONS_INDEX	    (1)
+#define CFG_BAUDRATE_TABLE	    { 9600, 19200, 38400, 57600, 115200, 230400 }
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Memory Test (mtest command) Stuff
+ */
+/* Default start address for memory test */
+#define CFG_MEMTEST_START	(PC20X_ONCHIP_SRAM_BASE)
+
+/* Default end address for memory test */
+#define CFG_MEMTEST_END		(CFG_MEMTEST_START + PC20X_ONCHIP_SRAM_SIZE - 1)
+
+/* Define this to use the super duper memory test */
+#define CFG_ALT_MEMTEST
+
+/* Use uart #1 scratch pad reg */
+#define CFG_MEMTEST_SCRATCH     (PC20X_UART1_BASE + UartScratchRegOffset)
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Supported Commands
+ */
+#include "config_cmd_default.h"
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_BSP
+
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_BOOTD
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_ECHO
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_ITEST
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_MISC
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_XIMG
+
+#ifdef CFG_NO_FLASH
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_ENV
+#endif /* CFG_NO_FLASH */
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+
+#ifdef  CFG_HUSH_PARSER
+/* This defines the secondary prompt string */
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif /* CFG_HUSH_PARSER */
+
+/* Enable command line editing and history */
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------------
+ * Miscellaneous Configurable Options...
+ */
+/* Use 'long' help messages */
+#define CFG_LONGHELP
+
+/* Monitor Command Prompt */
+#define CFG_PROMPT	"=> "
+
+/* Console I/O Buffer Size*/
+#define CFG_CBSIZE	(SZ_1K)
+
+/* Print buffer size */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)
+
+/* Maximum number of command args */
+#define CFG_MAXARGS	(16)
+
+/* Boot Argument Buffer Size*/
+#define CFG_BARGSIZE	(CFG_CBSIZE)
+
+/* everything, incl board info, in Hz */
+#undef	CFG_CLKS_IN_HZ
+
+/* Default load address for bootm and friends */
+#define CFG_LOAD_ADDR	(0x20080000)
+
+/*-----------------------------------------------------------------------
+ * Environment Configuration
+ */
+
+/* Note: This MAC address is based on the real picoChip OUI, it
+ * will need to be modified (as per the picoChip MAC address creation spec)
+ * for each and every board.
+ */
+
+#if defined(CFG_DW_EMAC)
+
+/* IPA OUI, will need noodling by users */
+#define CONFIG_ETHADDR          00:02:95:FF:FD:FD
+
+/* IPA default for testing, will need noodling by users */
+#define CONFIG_IPADDR           172.28.11.254
+
+#define CONFIG_HOSTNAME         ip202ff
+#define CONFIG_ROOTPATH	        /exports/sda7/3gap_boards/board5
+#define CONFIG_BOOTFILE	        uImage
+
+#define CONFIG_SERVERIP         172.28.0.138
+#define CONFIG_GATEWAYIP        172.28.0.254
+#define CONFIG_NETMASK          255.255.0.0
+
+#endif
+
+/* Second flash sector... */
+#define CFG_FLASH_KERNEL_BASE   0x20080000
+
+/* Second kernel flash sector... */
+#define CFG_FLASH_KERNEL_BASE2  0x20280000
+
+/* Default location for tftp and bootm */
+#define CONFIG_LOADADDR         0x00200000
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        5
+
+/* The boot command will set bootargs */
+#undef  CONFIG_BOOTARGS
+
+/* Default console baud rate */
+#define CONFIG_BAUDRATE	        115200
+
+#define CONFIG_BOOTCOUNT_LIMIT  4
+#define CONFIG_BOOT_RETRY_TIME  -1
+#define CONFIG_RESET_TO_RETRY
+
+#ifndef CONFIG_PC20X_2_DDR_RAM_BANKS
+/* We want a 4 DDR Bank setup then */
+
+/* Unless specified here we'll just rely on the kernel default */
+#define OTHERBOOTARGS
+
+#else   /* We want a 2 DDR Bank setup then */
+
+/* We need to 'over ride' the kernel default */
+#define OTHERBOOTARGS pc20x_mem=32M@PHYS_SDRAM_1 pc20x_mem=32M@PHYS_SDRAM_2
+
+#endif /* CONFIG_PC20X_2_DDR_RAM_BANKS */
+
+#define CONFIG_EXTRA_ENV_SETTINGS                                               \
+   "othbootargs=panic=1 " MK_STR (OTHERBOOTARGS) "\0"                           \
+   "netdev=eth0\0"                                                              \
+   "consoledev=/dev/null\0"                                                         \
+   "bootlimit=" MK_STR(CONFIG_BOOTCOUNT_LIMIT) "\0"                             \
+   "mtdparts=physmap-flash.0:" MTDPARTS_DEFAULT "\0"                            \
+   "nfs_args=setenv bootargs root=/dev/nfs rw nfsroot=$serverip:$rootpath"      \
+   " ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any"            \
+   " console=$consoledev,$baudrate $othbootargs mtdparts=$mtdparts;\0"          \
+   "fixed_nfs=run nfs_args; tftp; bootm\0"                                      \
+   "flash_args=setenv bootargs"                                                 \
+   " root=$rootdev ro rootfstype=cramfs,jffs2"                                  \
+   " ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any"            \
+   " console=$consoledev,$baudrate $othbootargs mtdparts=$mtdparts;\0"          \
+   "set_args_1=setenv kernel_addr " MK_STR(CFG_FLASH_KERNEL_BASE) ";"           \
+   " setenv rootdev /dev/mtdblock5\0"                                           \
+   "set_args_2=setenv kernel_addr " MK_STR(CFG_FLASH_KERNEL_BASE2) ";"          \
+   " setenv rootdev /dev/mtdblock6\0"                                           \
+   "check_bank=if test -z $bank; then setenv bank 1; fi\0"                      \
+   "bootflash=run check_bank;"                                                  \
+   " if test $bank -eq 1; then run set_args_1; else run set_args_2; fi;"        \
+   " run flash_args; bootm $kernel_addr || run altbootcmd\0"                    \
+   "altbootcmd=run check_bank;"                                                 \
+   " if test $bank -eq 1; then run set_args_2; else run set_args_1; fi;"        \
+   " run flash_args; bootm $kernel_addr || set_led red\0"                       \
+   "silent=on\0"
+
+#define CONFIG_NFSBOOTCOMMAND	                                        \
+   "setenv bootargs root=/dev/nfs rw "                                  \
+   "nfsroot=$serverip:$rootpath "                                       \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "bootm $kernel_flash_addr"
+
+#define CONFIG_RAMBOOTCOMMAND                                           \
+   "setenv bootargs root=/dev/ram rw "                                  \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "tftp $ramdiskaddr $ramdiskfile;"                                    \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr $ramdiskaddr"
+
+/* Define as "run flash_jffs2" for on-board boot, or "run fixed_nfs" for
+ * standard NFS with fixed IP.  Or use NFSBOOTCOMMAND etc as above.
+ */
+#define CONFIG_BOOTCOMMAND  "run bootflash"
+
+#endif /* __CONFIG_H */
diff -Naur pico_1.3.4/include/configs/ipaccessip302ff.h ipa_1.3.4/include/configs/ipaccessip302ff.h
--- pico_1.3.4/include/configs/ipaccessip302ff.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/include/configs/ipaccessip302ff.h	2011-06-24 11:21:58.000000000 +0100
@@ -0,0 +1,589 @@
+/*****************************************************************************
+ * BSP Version: 3.2.4, RevisionID: ac30f57, Date: 20100223 17:42:05
+ *****************************************************************************/
+
+/*!
+* \file picochippc7302.h
+* \brief Configuration file for U-Boot on the PC7302 platform.
+*
+* Copyright (c) 2006-2009 picoChip Designs Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/pc302.h>
+#include <asm/arch/sizes.h>
+#include <asm/arch/uart.h>
+
+/*-----------------------------------------------------------------------------
+ * Platform Identification Stuff
+ */
+#define PICOCHIP "picochip"
+
+/* Which hardware platform I am destined for */
+#define PICOCHIP_PLATFORM "pc7302"
+
+/* Specific version of this build */
+#ifndef PICOCHIP_PLATFORM_VERSION
+#define PICOCHIP_PLATFORM_VERSION "3.2.4"
+#endif /* PICOCHIP_PLATFORM_VERSION */
+
+#if 0
+#define CONFIG_IDENT_STRING " "PICOCHIP"-"PICOCHIP_PLATFORM_VERSION \
+                            "-"PICOCHIP_PLATFORM
+#endif
+
+/*-----------------------------------------------------------------------------
+ * High Level Configuration Options
+ */
+/* Running on picoChip PC302 Silicon */
+#define CONFIG_PICOCHIP_PC302
+
+/* Running on a picoChip PC7302 platform */
+#define CONFIG_PICOCHIP_PC7302
+
+/* Define this if running code in PC302 rtl simulation land */
+#undef CONFIG_PC302_SIMULATION
+
+/* Define to disable the verify after U-Boot has relocated from ROM to RAM */
+#undef CONFIG_SKIP_VERIFY_RELOCATE_UBOOT
+
+/* Bootable Flash memory has to live here (/ebi_decode0) */
+#define PC302_BOOTABLE_FLASH_BASE   (PC302_FLASH_BASE)
+
+/* Base address of the onchip SRAM */
+#define PC302_ONCHIP_SRAM_BASE      (PC302_SRAM_BASE)
+#define PC302_ONCHIP_SRAM_SIZE      (PC302_SRAM_SIZE)
+
+/* ARM Sub-system peripherals are clocked at 200MHz */
+#define PC302_AHB_CLOCK_FREQ        (200000000)
+
+/* Don't use Interrupts */
+#undef CONFIG_USE_IRQ
+
+/* Onchip timer runs at this frequency */
+#define CFG_HZ			    (PC302_AHB_CLOCK_FREQ)
+#define CONFIG_SYS_HZ               (CFG_HZ)
+
+/* Display board info */
+#define CONFIG_DISPLAY_BOARDINFO    (1)
+
+/* Are we are going to be running from RAM ? */
+#ifdef CONFIG_RUN_FROM_RAM
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SKIP_RELOCATE_UBOOT
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------
+ * Stack Sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land, reduce the stack sizes
+   so we do not have any memory model problems */
+#define CONFIG_STACKSIZE	(SZ_1K)             /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_128)            /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_128)    	    /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+#else
+/* We are running on a real hardware platform, therefore set the stack
+   sizes to their 'correct' values */
+#define CONFIG_STACKSIZE	(SZ_256K) 	    /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_4K)             /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_4K)    	    /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+
+#endif  /* CONFIG_PC302_SIMULATION */
+
+/*-----------------------------------------------------------------------------
+ * Size of malloc() pool
+ */
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+
+/* Memory size for use by malloc () */
+#define CFG_MALLOC_LEN		(SZ_4K)
+#else
+/* We are running on a real hardware platform */
+
+/* Memory size for use by malloc () */
+#define CFG_MALLOC_LEN		(SZ_256K)
+#endif  /* CONFIG_PC302_SIMULATION */
+
+/* Size in bytes reserved for initial data */
+#define CFG_GBL_DATA_SIZE	(SZ_256)
+
+/*-----------------------------------------------------------------------------
+ * Linux Kernel Stuff
+ */
+/* Allow passing of command line args (bootargs) to the linux kernel*/
+#define CONFIG_CMDLINE_TAG          1
+#define CONFIG_SETUP_MEMORY_TAGS    1
+
+/*-----------------------------------------------------------------------------
+ * DDR2 RAM Memory Map
+ */
+/* We have 1 linear addressable RAM bank */
+#define CONFIG_NR_DRAM_BANKS    (1)
+#define PHYS_SDRAM_1		(PC302_DDRBANK_BASE)
+#define PHYS_SDRAM_1_SIZE	(SZ_128M)
+
+/*-----------------------------------------------------------------------------
+ * Flash Memory Stuff
+ */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Define Flash memory sector size */
+#define FLASH_SECTOR_SIZE	(SZ_128K)
+
+#define CFG_FLASH_CFI
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_EMPTY_INFO
+
+/* Provide a much improved performance when writing to the Flash */
+#define CFG_FLASH_USE_BUFFER_WRITE
+
+#define CFG_FLASH_BASE		(PC302_BOOTABLE_FLASH_BASE)
+
+/* Maximum number of memory banks (devices) */
+#define CFG_MAX_FLASH_BANKS	(1)
+
+/* Maximum number of sectors per flash device */
+#define CFG_MAX_FLASH_SECT	(1024)
+
+/* Timeouts for Flash Erasing and writing */
+#define CFG_FLASH_ERASE_TOUT	(2*CFG_HZ)
+#define CFG_FLASH_WRITE_TOUT	(2*CFG_HZ)
+
+/* U-Boot occupies 3 Flash sectors */
+#define CFG_MONITOR_LEN		(3*FLASH_SECTOR_SIZE)
+
+/* U-Boot does not live in the bottom of the Flash memory any more */
+#define CFG_MONITOR_BASE        (CFG_FLASH_BASE+0x03E00000)
+
+#else
+
+/* No flash memory in the system */
+#define CFG_NO_FLASH
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+/*-----------------------------------------------------------------------------
+ * NAND Flash Memory Stuff
+ */
+#define CONFIG_SYS_NAND_BASE        PC302_EBI_CS2_BASE
+#define CONFIG_SYS_NAND_MAX_CHIPS   1
+#define CONFIG_SYS_MAX_NAND_DEVICE  1
+
+#define NAND_FLASH_SECTOR_SIZE      (SZ_128K)
+
+/* Pin definitions for NAND Flash control signals are
+ * defined in file board/picochip/pc7302/mt29f2g08aadwp.c
+ */
+
+/* Include support / commands for NAND Flash
+ *
+ * Note: Please read the comments in file
+ *       board/picochip/pc7302/mt29f2g08aadwp.c about gpio pins used
+ *       and PC302 booting modes before defining CONFIG_CMD_NAND
+ */
+// #define CONFIG_CMD_NAND
+
+/*-----------------------------------------------------------------------------
+ * SPI Flash Memory Stuff
+ */
+#define CFG_DW_SPI
+
+/* Include generic support for SPI Flash memory devices */
+#define CONFIG_SPI_FLASH
+
+/* Include support for SPI Flash memory devices from Spansion */
+#define CONFIG_SPI_FLASH_SPANSION
+
+/* Include support for SPI Flash memory devices from AMIC */
+#undef CONFIG_SPI_FLASH_AMIC
+
+/* Include support for SPI Flash memory devices from ST Micro/Numonyx */
+#define CONFIG_SPI_FLASH_STMICRO
+
+/* Include support for SPI Flash memory devices from EON */
+#define CONFIG_SPI_FLASH_EON
+
+/* flash layout for 64Mb+ boards - note that some of the partition definitions
+   specify addresses as we do not want MTD partition numbering to be sequential.
+   definitions without addresses follow directly after the previous parititon.
+ */
+#define MTDPARTS_64M  "384K@0x03e00000(uBoot),256K@0x40000(env),2M(kernel1),2M(kernel2),3584K(config)," \
+                      "27M(FS1),27M(FS2),256K@0(fsboot),128K@0x03e60000(oem_divert2),256K(oem_data1)," \
+                      "256K(oem_data2),256K(oem_lib1),256K(oem_lib2),256K(resv),256K(ipa_calib)"
+
+#define MTDPARTS_DEFAULT MTDPARTS_64M
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Environment Stuff
+ */
+#if defined(CONFIG_PC302_SIMULATION)
+
+/* We are running in RTL simulation land */
+
+/* No writable environment available in RTL sim land */
+#define CFG_ENV_IS_NOWHERE      (1)
+#define CFG_ENV_ADDR            (PC302_BOOTABLE_FLASH_BASE + FLASH_SECTOR_SIZE)
+
+/* One flash sector for environment info */
+#define CFG_ENV_SECT_SIZE       (FLASH_SECTOR_SIZE)
+
+/* But 2KBytes is sufficient */
+#define CFG_ENV_SIZE		(SZ_2K)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#else
+
+/* We are running on a real hardware platform */
+#ifndef CONFIG_RUN_FROM_RAM
+
+/* Environment variables stored in Flash memory */
+#define CFG_ENV_IS_IN_FLASH     (1)
+#define CFG_ENV_ADDR            (PC302_BOOTABLE_FLASH_BASE+(2*FLASH_SECTOR_SIZE))
+
+/* One flash sector for environment info */
+#define CFG_ENV_SECT_SIZE       (FLASH_SECTOR_SIZE)
+
+/* But 64 KBytes is sufficient */
+/* #define CFG_ENV_SIZE		(SZ_64K) */
+/* Better to leave env occupying a whole sector as it reduces number of writes */
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+/* Defining CFG_ENV_ADDR_REDUND enables redundant environment */
+#define CFG_ENV_ADDR_REDUND     (CFG_ENV_ADDR + FLASH_SECTOR_SIZE)
+
+#define CONFIG_FALLBACK_TO_NONREDUND_ENV        /* Enable for upgrades from old env format */
+
+#elif defined(CONFIG_CMD_NAND)
+
+/* We are runing from ram with NAND support */
+
+/* NAND Flash memory map
+ *
+ *  Block 0 U-Boot image
+ *  Block 1 Redundant U-Boot image
+ *  Block 2 Spare
+ *  Block 3 Spare
+ *  Block 4 U-Boot Environment
+ *  Block 5 Redundant U-Boot environment
+ *  Block 6 Spare
+ *  Block 7 Spare
+ *  Block 8 Linux kernel
+ *
+ */
+#define CFG_ENV_IS_IN_NAND      (1)
+#define CFG_ENV_OFFSET          (NAND_FLASH_SECTOR_SIZE * 4)
+#define CFG_ENV_SIZE            (NAND_FLASH_SECTOR_SIZE)
+#define CFG_ENV_OFFSET_REDUND   (NAND_FLASH_SECTOR_SIZE * 5)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#else
+
+/* We are running from ram, therefore no environment */
+#define CFG_ENV_IS_NOWHERE
+
+/* Need to define this for the build to be successful */
+#define CFG_ENV_SIZE		(SZ_64K)
+
+#endif /* CONFIG_RUN_FROM_RAM */
+
+#endif /* CONFIG_PC302_SIMULATION */
+
+/*-----------------------------------------------------------------------------
+ * Timer Stuff
+ */
+#define CFG_TIMERBASE           (PC302_TIMER_BASE)
+
+/*-----------------------------------------------------------------------------
+ * Ethernet Stuff
+ */
+#define CFG_DW_EMAC
+#define CONFIG_PHY_ADDR         (1)
+#define CONFIG_NET_MULTI
+
+/*-----------------------------------------------------------------------------
+ * Serial Port Stuff
+ */
+#define CFG_DW_APB_UART
+
+/* Baud rate generators clock with a 3.6864 MHz clock */
+#define CONFIG_DW_APB_UART_CLOCK    (3686400)
+
+/* Console on Uart #0 */
+#define CONFIG_CONS_INDEX	    (1)
+#define CFG_BAUDRATE_TABLE	    { 9600, 19200, 38400, 57600, 115200, 230400 }
+
+/*-----------------------------------------------------------------------------
+ * Watchdog Stuff
+ */
+/* Use the GPIO reset method as supported on this hardware platform
+   Note: Undef this macro to use the 'fallback' watcdog reset method */
+#undef CONFIG_USE_GPIO_RESET_METHOD
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Memory Test (mtest command) Stuff
+ */
+/* Default start address for memory test */
+#define CFG_MEMTEST_START	(PC302_ONCHIP_SRAM_BASE)
+
+/* Default end address for memory test */
+#define CFG_MEMTEST_END		(CFG_MEMTEST_START + PC302_ONCHIP_SRAM_SIZE - 1)
+
+/* Define this to use the super duper memory test */
+#define CFG_ALT_MEMTEST
+
+/* Use Uart #1 scratch pad reg */
+#define CFG_MEMTEST_SCRATCH     (PC302_UART1_BASE + UART_SCRATCH_REG_OFFSET)
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Supported Commands
+ */
+#include "config_cmd_default.h"
+
+#define CONFIG_CMD_PING
+
+/* Include commands for SPI bus */
+#undef CONFIG_CMD_SPI
+
+/* Include commands for SPI Flash memory */
+#define CONFIG_CMD_SF
+
+/* Include commands for BSP specific command */
+#define CONFIG_CMD_BSP
+
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_BOOTD
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_ECHO
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_ITEST
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_MISC
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_SETGETDCR
+#undef CONFIG_CMD_XIMG
+
+#ifdef CFG_NO_FLASH
+#undef CONFIG_CMD_FLASH
+#endif /* CFG_NO_FLASH */
+
+#ifdef CFG_ENV_IS_NOWHERE
+#undef CONFIG_CMD_ENV
+#endif /* CFG_ENV_IS_NOWHERE */
+
+
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+
+/* Do not use the HUSH parser */
+#undef  CFG_HUSH_PARSER
+#else
+/* We are running on a real hardware platform */
+
+/* Use the HUSH parser */
+#define CFG_HUSH_PARSER
+#endif /* CONFIG_PC302_SIMULATION */
+
+#ifdef  CFG_HUSH_PARSER
+/* This defines the secondary prompt string */
+#define CFG_PROMPT_HUSH_PS2 "> "
+#endif /* CFG_HUSH_PARSER */
+
+/* Enable command line editing and history */
+#define CONFIG_CMDLINE_EDITING
+
+/* Enable gpio test commands */
+#define CONFIG_CMD_PC302_GPIO
+
+/*-----------------------------------------------------------------------------
+ * Miscellaneous Configurable Options...
+ */
+/* Use 'long' help messages */
+#define CFG_LONGHELP
+
+/* Monitor Command Prompt */
+#define CFG_PROMPT	"=> "
+
+/* Console I/O Buffer Size*/
+#define CFG_CBSIZE	(SZ_1K)
+
+/* Print buffer size */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16)
+
+/* Maximum number of command args */
+#define CFG_MAXARGS	(16)
+#define CONFIG_SYS_MAXARGS (CFG_MAXARGS)
+
+#define CONFIG_SYS_HELP_CMD_WIDTH (79)
+
+/* Boot Argument Buffer Size */
+#define CFG_BARGSIZE	(CFG_CBSIZE)
+
+/* everything, incl board info, in Hz */
+#undef	CFG_CLKS_IN_HZ
+
+/* Default load address for bootm and friends */
+#define CFG_LOAD_ADDR	        (0x00200000)
+#define CONFIG_SYS_LOAD_ADDR    (CFG_LOAD_ADDR)
+/*-----------------------------------------------------------------------
+ * Environment Configuration
+ */
+
+/* Note: The MAC Address defined by 'CONFIG_ETHADDR' is based on
+ * picoChip's OUI,see http://standards.ieee.org/regauth/oui/index.shtml
+ * for more information. It will need to be modified for each and every
+ * individual hardware platform.
+ */
+
+#if defined(CFG_DW_EMAC)
+
+/* picoChip OUI, will need noodling by users */
+#define CONFIG_ETHADDR          00:02:95:FF:FD:FD
+
+/* picoChip default for testing, will need noodling by users */
+#define CONFIG_IPADDR           172.28.11.254
+
+#define CONFIG_HOSTNAME	        ip302ff
+#define CONFIG_ROOTPATH	        /exports/home/nm1/pc7302_test
+#define CONFIG_BOOTFILE	        uImage-pc7302_test
+
+#define CONFIG_SERVERIP         172.28.1.211
+#define CONFIG_GATEWAYIP        172.28.0.254
+#define CONFIG_NETMASK          255.255.0.0
+
+#endif /* CFG_DW_EMAC */
+
+/* Second flash sector... */
+#define CFG_FLASH_KERNEL_BASE   0x40080000
+#define CFG_FLASH_KERNEL_BASE2  0x40280000
+
+/* This is the offset from the start of NAND Flash
+ * to where the Linux kernel can be found.
+ */
+#define NAND_KERNEL_OFFSET      0x00100000
+
+/* Default location for tftp and bootm */
+#define CONFIG_LOADADDR         0x00200000
+
+#if defined(CONFIG_PC302_SIMULATION)
+/* We are running in RTL simulation land */
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        -1
+#else
+/* We are running on a real hardware platform */
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        5
+#endif  /* CONFIG_PC302_SIMULATION */
+
+/* The boot command will set bootargs */
+#undef  CONFIG_BOOTARGS
+
+/* Default console baud rate */
+#define CONFIG_BAUDRATE	        115200
+
+#define CONFIG_BOOTCOUNT_LIMIT  4
+#define CONFIG_BOOT_RETRY_TIME  -1
+#undef CONFIG_BOOT_RETRY_TIME
+#define CONFIG_RESET_TO_RETRY
+
+/* Unless specified here we'll just rely on the kernel default */
+#define OTHERBOOTARGS
+
+#define CONFIG_EXTRA_ENV_SETTINGS                                               \
+   "othbootargs=panic=1 " MK_STR (OTHERBOOTARGS) "\0"                           \
+   "netdev=eth0\0"                                                              \
+   "consoledev=/dev/null\0"                                                     \
+   "bootlimit=" MK_STR(CONFIG_BOOTCOUNT_LIMIT) "\0"                             \
+   "kernel_nand_offset=" MK_STR(NAND_KERNEL_OFFSET) "\0"                        \
+   "mtdparts=physmap-flash.0:" MTDPARTS_DEFAULT "\0"                            \
+   "nfs_args=setenv bootargs root=/dev/nfs rw nfsroot=$serverip:$rootpath"      \
+   " ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any"            \
+   " console=$consoledev,$baudrate $othbootargs mtdparts=$mtdparts;\0"          \
+   "fixed_nfs=run nfs_args; tftp; bootm\0"                                      \
+   "nand_jffs2=run nand_jffs2_args; nboot $loadaddr 0 "                         \
+   "$kernel_nand_offset; bootm $loaddddr\0"                                     \
+   "nand_jffs2_args=setenv bootargs root=/dev/mtdblock6 rw rootfstype=jffs2 "   \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "            \
+   "console=$consoledev,$baudrate $othbootargs;\0"                              \
+   "flash_args=setenv bootargs"                                                 \
+   " root=$rootdev ro rootfstype=cramfs,jffs2"                                  \
+   " ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any"            \
+   " console=$consoledev,$baudrate $othbootargs mtdparts=$mtdparts;\0"          \
+   "set_args_1=setenv kernel_addr " MK_STR(CFG_FLASH_KERNEL_BASE) ";"           \
+   " setenv rootdev /dev/mtdblock5\0"                                           \
+   "set_args_2=setenv kernel_addr " MK_STR(CFG_FLASH_KERNEL_BASE2) ";"          \
+   " setenv rootdev /dev/mtdblock6\0"                                           \
+   "check_bank=if test -z $bank; then setenv bank 1; fi\0"                      \
+   "bootflash=run check_bank;"                                                  \
+   " if test $bank -eq 1; then run set_args_1; else run set_args_2; fi;"        \
+   " run flash_args; bootm $kernel_addr || run altbootcmd\0"                    \
+   "altbootcmd=run check_bank;"                                                 \
+   " if test $bank -eq 1; then run set_args_2; else run set_args_1; fi;"        \
+   " run flash_args; bootm $kernel_addr || set_led red\0"                       \
+   "silent=on\0"
+
+#define CONFIG_NFSBOOTCOMMAND                                           \
+   "setenv bootargs root=/dev/nfs rw "                                  \
+   "nfsroot=$serverip:$rootpath "                                       \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "    \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "bootm $kernel_flash_addr"
+
+#define CONFIG_RAMBOOTCOMMAND                                           \
+   "setenv bootargs root=/dev/ram rw "                                  \
+   "console=$consoledev,$baudrate $othbootargs;"                        \
+   "tftp $ramdiskaddr $ramdiskfile;"                                    \
+   "tftp $loadaddr $bootfile;"                                          \
+   "bootm $loadaddr $ramdiskaddr"
+
+/* Define as "run bootflash" for on-board boot from parallel nor flash,
+ * or "run nand_jffs2" for on-board boot from nand flash or
+ * "run fixed_nfs" for standard NFS with fixed IP address.
+ */
+#if defined(CONFIG_CMD_NAND)
+
+#define CONFIG_BOOTCOMMAND  "run nand_jffs2"
+
+#else
+
+#define CONFIG_BOOTCOMMAND  "run bootflash"
+
+
+#endif
+
+/* perform digital signature verification on the kernel image
+ * before passing control to it.
+ */
+#define CONFIG_VERIFY_KERNEL	 1
+/* address of stand alone application which performs the digital
+ * signature verification.
+ */
+#define VALIDATE_APP_ADDR        (CFG_MONITOR_BASE + CFG_MONITOR_LEN - SZ_64K - SZ_128K)
+
+#endif /* __CONFIG_H */
+
diff -Naur pico_1.3.4/mkconfig ipa_1.3.4/mkconfig
--- pico_1.3.4/mkconfig	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/mkconfig	2011-04-26 11:53:24.000000000 +0100
@@ -11,6 +11,8 @@
 APPEND=no	# Default: Create new config file
 BOARD_NAME=""	# Name to print in make output
 
+echo "args $1 $2 $3 $4 $5 $6 $7 $8"
+
 while [ $# -gt 0 ] ; do
 	case "$1" in
 	--) shift ; break ;;
@@ -23,7 +25,13 @@
 [ "${BOARD_NAME}" ] || BOARD_NAME="$1"
 
 [ $# -lt 4 ] && exit 1
-[ $# -gt 6 ] && exit 1
+[ $# -gt 8 ] && exit 1
+
+if [ "$7" = "" ]
+then
+  echo "IPA board type is not set try with for e.g TYPE=xb"
+  exit 1
+fi
 
 echo "Configuring for ${BOARD_NAME} board..."
 
@@ -81,7 +89,33 @@
 else
 	> config.h		# Create new config file
 fi
+
 echo "/* Automatically generated - do not edit */" >>config.h
+
+echo "IPA board type is set to $7"
+touch ipa_config.h
+
+echo "/* Automatically generated - do not edit */" >>ipa_config.h
+
+type=""
+case "$7" in
+    "xb")
+        echo "#define IPA_BOARD_TYPE_XB 1 " >>ipa_config.h
+        ;;
+    "xbplus")
+        echo "#define IPA_BOARD_TYPE_XBPLUS 1" >>ipa_config.h
+        ;;
+    "xc")
+        echo "#define IPA_BOARD_TYPE_XC 1" >>ipa_config.h
+        ;;
+    "xcminus")
+        echo "#define IPA_BOARD_TYPE_XCMINUS 1" >>ipa_config.h
+        ;;
+esac
+
+echo "#define CONFIG_IDENT_STRING \" $4-$7-$8\"" >>ipa_config.h
+echo "#define CONFIG_SILENT_CONSOLE" >>ipa_config.h
+echo "#include <ipa_config.h>" >>config.h
 echo "#include <configs/$1.h>" >>config.h
 
 exit 0
diff -Naur pico_1.3.4/tools/Makefile ipa_1.3.4/tools/Makefile
--- pico_1.3.4/tools/Makefile	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/tools/Makefile	2011-04-26 11:53:24.000000000 +0100
@@ -21,10 +21,10 @@
 # MA 02111-1307 USA
 #
 
-BIN_FILES	= img2srec$(SFX) mkimage$(SFX) envcrc$(SFX) ubsha1$(SFX) gen_eth_addr$(SFX) bmp_logo$(SFX)
+BIN_FILES	= img2srec$(SFX) mkimage$(SFX) envcrc$(SFX) ubsha1$(SFX) gen_eth_addr$(SFX) bmp_logo$(SFX) ubootenv$(SFX)
 
 OBJ_LINKS	= environment.o crc32.o md5.o sha1.o image.o
-OBJ_FILES	= img2srec.o mkimage.o envcrc.o ubsha1.o gen_eth_addr.o bmp_logo.o
+OBJ_FILES	= img2srec.o mkimage.o envcrc.o ubsha1.o gen_eth_addr.o bmp_logo.o ubootenv.o
 
 ifeq ($(ARCH),mips)
 BIN_FILES	+= inca-swap-bytes$(SFX)
@@ -171,6 +171,10 @@
 		$(CC) $(CFLAGS) $(HOST_LDFLAGS) -o $@ $^
 		$(STRIP) $@
 
+$(obj)ubootenv$(SFX):	$(obj)ubootenv.o $(obj)crc32.o
+		$(CC) $(CFLAGS) $(HOST_LDFLAGS) -o $@ $^
+		$(STRIP) $@
+
 $(obj)envcrc.o:	$(src)envcrc.c
 		$(CC) -g $(CFLAGS) -c -o $@ $<
 
@@ -219,6 +223,9 @@
 $(obj)fdt_wip.o:	$(obj)fdt_wip.c
 		$(CC) -g $(FIT_CFLAGS) -c -o $@ $<
 
+$(obj)ubootenv.o:	$(src)ubootenv.c
+		$(CC) -g $(CFLAGS) -c -o $@ $<
+
 subdirs:
 ifeq ($(TOOLSUBDIRS),)
 		@:
diff -Naur pico_1.3.4/tools/env/Makefile ipa_1.3.4/tools/env/Makefile
--- pico_1.3.4/tools/env/Makefile	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/tools/env/Makefile	2011-04-26 11:53:24.000000000 +0100
@@ -1,5 +1,5 @@
 #
-# (C) Copyright 2002-2006
+# (C) Copyright 2002
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
 # See file CREDITS for list of people who contributed to this
@@ -21,32 +21,36 @@
 # MA 02111-1307 USA
 #
 
-include $(TOPDIR)/config.mk
+#CROSS_COMPILE = arm-none-linux-gnueabi-
+#CC = arm-none-linux-gnueabi-gcc
 
-SRCS	:= $(obj)crc32.c  fw_env.c  fw_env_main.c
-HEADERS	:= fw_env.h
+SOURCES := crc32.c  fw_env.c  fw_env_main.c
+HEADERS := fw_env.h
 
-CPPFLAGS := -Wall -DUSE_HOSTCC -I$(SRCTREE)/include
+CPPFLAGS := -Wall -DUSE_HOSTCC
+CPPFLAGS := -g -Wall -DUSE_HOSTCC -I ../../include -I .-idirafter 
 
 ifeq ($(MTD_VERSION),old)
 CPPFLAGS += -DMTD_OLD
 endif
 
-all:	$(obj)fw_printenv
 
-$(obj)fw_printenv:	$(SRCS) $(HEADERS)
-	$(CROSS_COMPILE)gcc $(CPPFLAGS) $(SRCS) -o $(obj)fw_printenv
+all:	fw_printenv
+
+fw_printenv:	$(SOURCES) $(HEADERS)
+	$(CROSS_COMPILE)gcc $(CPPFLAGS) $(SOURCES) -o fw_printenv
 
 clean:
-	rm -f $(obj)fw_printenv $(obj)crc32.c
+	rm -f fw_printenv crc32.c
 
-$(obj)crc32.c:
-	ln -s $(src)../../lib_generic/crc32.c $(obj)crc32.c
+crc32.c:
+	ln -s ../../lib_generic/crc32.c crc32.c
 
 #########################################################################
 
-include $(TOPDIR)/rules.mk
+.depend:	Makefile $(SOURCES)
+		$(CROSS_COMPILE)gcc -M $(HOST_CFLAGS) $(CPPFLAGS) -I ../../include -I .  -g  -DUSE_HOSTCC $(SOURCES) > $@
 
-sinclude $(obj).depend
+sinclude .depend
 
 #########################################################################
diff -Naur pico_1.3.4/tools/env/fw_env.c ipa_1.3.4/tools/env/fw_env.c
--- pico_1.3.4/tools/env/fw_env.c	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/tools/env/fw_env.c	2011-04-26 11:53:24.000000000 +0100
@@ -31,12 +31,16 @@
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <unistd.h>
+#include <stdint.h>
 
 #ifdef MTD_OLD
 # include <linux/mtd/mtd.h>
 #else
 # define  __user	/* nothing */
 # include <mtd/mtd-user.h>
+  /* Include the config from the U-Boot image, but don't include ethaddr. */
+# include "config.h"
+# undef CONFIG_ETHADDR
 #endif
 
 #include "fw_env.h"
@@ -59,7 +63,10 @@
 #define ENVSIZE(i)    envdevices[(i)].env_size
 #define DEVESIZE(i)   envdevices[(i)].erase_size
 
+#ifdef CONFIG_FILE
+#undef CFG_ENV_SIZE
 #define CFG_ENV_SIZE ENVSIZE(curdev)
+#endif /* CONFIG_FILE */
 
 #define ENV_SIZE      getenvsize()
 
@@ -321,6 +328,7 @@
 	 * Delete any existing definition
 	 */
 	if (oldval) {
+#ifndef CONFIG_ENV_OVERWRITE
 		/*
 		 * Ethernet Address and serial# can be set only once
 		 */
@@ -329,6 +337,7 @@
 			fprintf (stderr, "Can't overwrite \"%s\"\n", name);
 			return (EROFS);
 		}
+#endif /* CONFIG_ENV_OVERWRITE */
 
 		if (*++nxt == '\0') {
 			*env = '\0';
@@ -394,6 +403,64 @@
 	return (0);
 }
 
+/* 
+ * Break down a read from Flash into smaller pieces to kernel driver does not
+ * need to allocate such a big buffer.
+ */
+static int flash_read (int fd, char *buf, int len)
+{
+    const int FLASH_READ_CHUNK = 2048;
+    int remaining;
+
+    remaining = len;
+    while (remaining > 0) {
+        int n;
+        int rc;
+        if (remaining >= FLASH_READ_CHUNK) {
+            n = FLASH_READ_CHUNK;
+        } else {
+            n = remaining;
+        }
+
+        rc = read (fd, buf, n);
+        if (rc != n) {
+            return rc;
+        }
+
+        buf += n;
+        remaining -= n;
+    }
+    return len;
+} /* flash_read() */
+
+
+static int flash_write (int fd, const char *buf, int len)
+{
+    const int FLASH_WRITE_CHUNK = 2048;
+    int remaining;
+
+    remaining = len;
+    while (remaining > 0) {
+        int n;
+        int rc;
+        if (remaining >= FLASH_WRITE_CHUNK) {
+            n = FLASH_WRITE_CHUNK;
+        } else {
+            n = remaining;
+        }
+
+        rc = write (fd, buf, n);
+        if (rc != n) {
+            return rc;
+        }
+
+        buf += n;
+        remaining -= n;
+    }
+
+    return len;
+} /* flash_write() */
+
 static int flash_io (int mode)
 {
 	int fd, fdr, rc, otherdev, len, resid;
@@ -441,10 +508,13 @@
 
 		printf ("Done\n");
 		resid = DEVESIZE (otherdev) - CFG_ENV_SIZE;
+#ifdef ENV_DEBUG
+                fprintf(stderr, "devsize %u cfg_env %u", DEVESIZE (otherdev), CFG_ENV_SIZE);
+#endif /* ENV_DEBUG */
 		if (resid) {
 			if ((data = malloc (resid)) == NULL) {
 				fprintf (stderr,
-					"Cannot malloc %d bytes: %s\n",
+					"Cannot malloc %u bytes: %s\n",
 					resid,
 					strerror (errno));
 				return (-1);
@@ -456,7 +526,7 @@
 					strerror (errno));
 				return (-1);
 			}
-			if ((rc = read (fdr, data, resid)) != resid) {
+			if ((rc = flash_read (fdr, data, resid)) != resid) {
 				fprintf (stderr,
 					"read error on %s: %s\n",
 					DEVNAME (otherdev),
@@ -485,20 +555,20 @@
 				DEVNAME (otherdev), strerror (errno));
 			return (-1);
 		}
-		if (write (fdr, &environment, len) != len) {
+		if (flash_write (fdr, &environment, len) != len) {
 			fprintf (stderr,
 				"CRC write error on %s: %s\n",
 				DEVNAME (otherdev), strerror (errno));
 			return (-1);
 		}
-		if (write (fdr, environment.data, ENV_SIZE) != ENV_SIZE) {
+		if (flash_write (fdr, environment.data, ENV_SIZE) != ENV_SIZE) {
 			fprintf (stderr,
 				"Write error on %s: %s\n",
 				DEVNAME (otherdev), strerror (errno));
 			return (-1);
 		}
 		if (resid) {
-			if (write (fdr, data, resid) != resid) {
+			if (flash_write (fdr, data, resid) != resid) {
 				fprintf (stderr,
 					"write error on %s: %s\n",
 					DEVNAME (curdev), strerror (errno));
@@ -514,7 +584,7 @@
 					DEVNAME (curdev), strerror (errno));
 				return (-1);
 			}
-			if (write (fd, &obsolete_flag, sizeof (obsolete_flag)) !=
+			if (flash_write (fd, &obsolete_flag, sizeof (obsolete_flag)) !=
 				sizeof (obsolete_flag)) {
 				fprintf (stderr,
 					"Write error on %s: %s\n",
@@ -548,13 +618,13 @@
 				DEVNAME (curdev), strerror (errno));
 			return (-1);
 		}
-		if (read (fd, &environment, len) != len) {
+		if (flash_read (fd, &environment, len) != len) {
 			fprintf (stderr,
 				"CRC read error on %s: %s\n",
 				DEVNAME (curdev), strerror (errno));
 			return (-1);
 		}
-		if ((rc = read (fd, environment.data, ENV_SIZE)) != ENV_SIZE) {
+		if ((rc = flash_read (fd, environment.data, ENV_SIZE)) != ENV_SIZE) {
 			fprintf (stderr,
 				"Read error on %s: %s\n",
 				DEVNAME (curdev), strerror (errno));
@@ -618,8 +688,27 @@
 		return (errno);
 	}
 
+#ifdef ENV_DEBUG
+    fprintf(stderr, "env_size = %u\n", ENV_SIZE);
+#endif /* ENV_DEBUG */
+
 	crc1_ok = ((crc1 = crc32 (0, (uint8_t *) environment.data, ENV_SIZE))
 			   == environment.crc);
+#if 0
+	printf("\n");
+	  
+	{
+		int i;
+
+		for(i=0; i<ENV_SIZE; i++)
+		{
+			printf("%c", environment.data[i]);
+		}
+	}
+	
+	printf("\n");
+#endif
+
 	if (!HaveRedundEnv) {
 		if (!crc1_ok) {
 			fprintf (stderr,
@@ -737,6 +826,11 @@
 			DEVNAME (1), strerror (errno));
 		return 1;
 	}
+
+#ifdef ENV_DEBUG
+        fprintf(stderr, "devname= %s offset= %x size= %x esize= %x\n", DEVNAME (0), DEVOFFSET (0), ENVSIZE (0), DEVESIZE (0));
+#endif /* ENV_DEBUG */
+
 	return 0;
 }
 
diff -Naur pico_1.3.4/tools/env/fw_env.config ipa_1.3.4/tools/env/fw_env.config
--- pico_1.3.4/tools/env/fw_env.config	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/tools/env/fw_env.config	2011-04-26 11:53:24.000000000 +0100
@@ -3,5 +3,5 @@
 # environment sector is assumed present.
 
 # MTD device name	Device offset	Env. size	Flash sector size
-/dev/mtd1		0x0000		0x4000		0x4000
-/dev/mtd2		0x0000		0x4000		0x4000
+/dev/mtd1		0x00000		0x20000		0x20000
+/dev/mtd1		0x20000		0x20000		0x20000
diff -Naur pico_1.3.4/tools/env/fw_env.h ipa_1.3.4/tools/env/fw_env.h
--- pico_1.3.4/tools/env/fw_env.h	2008-08-12 15:08:38.000000000 +0100
+++ ipa_1.3.4/tools/env/fw_env.h	2011-04-26 11:53:24.000000000 +0100
@@ -29,23 +29,26 @@
  */
 #define CONFIG_FILE     "/etc/fw_env.config"
 
-#define HAVE_REDUND /* For systems with 2 env sectors */
-#define DEVICE1_NAME      "/dev/mtd1"
+/* Only used if CONFIG_FILE is not defined */
+#undef HAVE_REDUND /* For systems with 2 env sectors */
+#define DEVICE1_NAME      "/dev/mtd4"
 #define DEVICE2_NAME      "/dev/mtd2"
-#define DEVICE1_OFFSET    0x0000
-#define ENV1_SIZE         0x4000
-#define DEVICE1_ESIZE     0x4000
+#define DEVICE1_OFFSET    0x00000
+#define ENV1_SIZE         0x40000
+#define DEVICE1_ESIZE     0x20000
 #define DEVICE2_OFFSET    0x0000
 #define ENV2_SIZE         0x4000
 #define DEVICE2_ESIZE     0x4000
 
+#if 0
 #define CONFIG_BAUDRATE		115200
 #define CONFIG_BOOTDELAY	5	/* autoboot after 5 seconds	*/
 #define CONFIG_BOOTCOMMAND							\
 	"bootp; "								\
-	"setenv bootargs root=/dev/nfs nfsroot=${serverip}:${rootpath} "	\
-	"ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}:${hostname}::off; "	\
+	"setenv bootargs root=/dev/nfs nfsroot=$(serverip):$(rootpath) " 	\
+	"ip=$(ipaddr):$(serverip):$(gatewayip):$(netmask):$(hostname)::off; " 	\
 	"bootm"
+#endif
 
 extern int   fw_printenv(int argc, char *argv[]);
 extern char *fw_getenv  (char *name);
diff -Naur pico_1.3.4/tools/env/mtd/mtd-abi.h ipa_1.3.4/tools/env/mtd/mtd-abi.h
--- pico_1.3.4/tools/env/mtd/mtd-abi.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/tools/env/mtd/mtd-abi.h	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,102 @@
+/*
+ * $Id: PC202/uboot1.x/u-boot-1.3.4-ipa-3.2.4-patch 1.4.1.1 2011/04/26 12:44:40BST Ian Hamilton (ih3) Exp  $
+ *
+ * Portions of MTD ABI definition which are shared by kernel and user space 
+ */
+
+#ifndef __MTD_ABI_H__
+#define __MTD_ABI_H__
+
+#ifndef __KERNEL__ /* Urgh. The whole point of splitting this out into
+		    separate files was to avoid #ifdef __KERNEL__ */
+#define __user
+#endif
+
+struct erase_info_user {
+	uint32_t start;
+	uint32_t length;
+};
+
+struct mtd_oob_buf {
+	uint32_t start;
+	uint32_t length;
+	unsigned char __user *ptr;
+};
+
+#define MTD_ABSENT		0
+#define MTD_RAM			1
+#define MTD_ROM			2
+#define MTD_NORFLASH		3
+#define MTD_NANDFLASH		4
+#define MTD_PEROM		5
+#define MTD_OTHER		14
+#define MTD_UNKNOWN		15
+
+#define MTD_CLEAR_BITS		1       // Bits can be cleared (flash)
+#define MTD_SET_BITS		2       // Bits can be set
+#define MTD_ERASEABLE		4       // Has an erase function
+#define MTD_WRITEB_WRITEABLE	8       // Direct IO is possible
+#define MTD_VOLATILE		16      // Set for RAMs
+#define MTD_XIP			32	// eXecute-In-Place possible
+#define MTD_OOB			64	// Out-of-band data (NAND flash)
+#define MTD_ECC			128	// Device capable of automatic ECC
+
+// Some common devices / combinations of capabilities
+#define MTD_CAP_ROM		0
+#define MTD_CAP_RAM		(MTD_CLEAR_BITS|MTD_SET_BITS|MTD_WRITEB_WRITEABLE)
+#define MTD_CAP_NORFLASH        (MTD_CLEAR_BITS|MTD_ERASEABLE)
+#define MTD_CAP_NANDFLASH       (MTD_CLEAR_BITS|MTD_ERASEABLE|MTD_OOB)
+#define MTD_WRITEABLE		(MTD_CLEAR_BITS|MTD_SET_BITS)
+
+
+// Types of automatic ECC/Checksum available
+#define MTD_ECC_NONE		0 	// No automatic ECC available
+#define MTD_ECC_RS_DiskOnChip	1	// Automatic ECC on DiskOnChip
+#define MTD_ECC_SW		2	// SW ECC for Toshiba & Samsung devices
+
+/* ECC byte placement */
+#define MTD_NANDECC_OFF		0	// Switch off ECC (Not recommended)
+#define MTD_NANDECC_PLACE	1	// Use the given placement in the structure (YAFFS1 legacy mode)
+#define MTD_NANDECC_AUTOPLACE	2	// Use the default placement scheme
+#define MTD_NANDECC_PLACEONLY	3	// Use the given placement in the structure (Do not store ecc result on read)
+
+struct mtd_info_user {
+	uint8_t type;
+	uint32_t flags;
+	uint32_t size;	 // Total size of the MTD
+	uint32_t erasesize;
+	uint32_t oobblock;  // Size of OOB blocks (e.g. 512)
+	uint32_t oobsize;   // Amount of OOB data per block (e.g. 16)
+	uint32_t ecctype;
+	uint32_t eccsize;
+};
+
+struct region_info_user {
+	uint32_t offset;		/* At which this region starts, 
+					 * from the beginning of the MTD */
+	uint32_t erasesize;		/* For this region */
+	uint32_t numblocks;		/* Number of blocks in this region */
+	uint32_t regionindex;
+};
+
+#define MEMGETINFO              _IOR('M', 1, struct mtd_info_user)
+#define MEMERASE                _IOW('M', 2, struct erase_info_user)
+#define MEMWRITEOOB             _IOWR('M', 3, struct mtd_oob_buf)
+#define MEMREADOOB              _IOWR('M', 4, struct mtd_oob_buf)
+#define MEMLOCK                 _IOW('M', 5, struct erase_info_user)
+#define MEMUNLOCK               _IOW('M', 6, struct erase_info_user)
+#define MEMGETREGIONCOUNT	_IOR('M', 7, int)
+#define MEMGETREGIONINFO	_IOWR('M', 8, struct region_info_user)
+#define MEMSETOOBSEL		_IOW('M', 9, struct nand_oobinfo)
+#define MEMGETOOBSEL		_IOR('M', 10, struct nand_oobinfo)
+#define MEMGETBADBLOCK		_IOW('M', 11, loff_t)
+#define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
+
+struct nand_oobinfo {
+	uint32_t useecc;
+	uint32_t eccbytes;
+	uint32_t oobfree[8][2];
+	uint32_t eccpos[32];
+};
+
+#endif /* __MTD_ABI_H__ */
diff -Naur pico_1.3.4/tools/env/mtd-user.h ipa_1.3.4/tools/env/mtd-user.h
--- pico_1.3.4/tools/env/mtd-user.h	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/tools/env/mtd-user.h	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,20 @@
+/*
+ * $Id: PC202/uboot1.x/u-boot-1.3.4-ipa-3.2.4-patch 1.4.1.1 2011/04/26 12:44:40BST Ian Hamilton (ih3) Exp  $
+ *
+ * MTD ABI header for use by user space only.
+ */
+
+#ifndef __MTD_USER_H__
+#define __MTD_USER_H__
+
+#include <stdint.h>
+
+/* This file is blessed for inclusion by userspace */
+#include <mtd/mtd-abi.h>
+
+typedef struct mtd_info_user mtd_info_t;
+typedef struct erase_info_user erase_info_t;
+typedef struct region_info_user region_info_t;
+typedef struct nand_oobinfo nand_oobinfo_t;
+
+#endif /* __MTD_USER_H__ */
diff -Naur pico_1.3.4/tools/ubootenv.c ipa_1.3.4/tools/ubootenv.c
--- pico_1.3.4/tools/ubootenv.c	1970-01-01 01:00:00.000000000 +0100
+++ ipa_1.3.4/tools/ubootenv.c	2011-04-26 11:53:24.000000000 +0100
@@ -0,0 +1,110 @@
+/* 
+ * ubootenv.c
+ * 
+ * Copyright (c) 2009 ip.access Ltd.
+ *
+ * Process a file of U-Boot env assignments into a binary
+ * file suitable for copying to Flash.
+ * 
+ * The input file should contain lines like:
+bootdelay=5
+baudrate=115200
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <malloc.h>
+
+extern unsigned long crc32 (unsigned long, const unsigned char *, unsigned int);
+
+
+#define UB_ENV_SIZE (0x20000-5)
+unsigned char *env_buffer;
+
+int
+main(int argc, char *argv[])
+{
+    FILE *ifp, *ofp;
+    char line[LINE_MAX];
+    unsigned char *envptr;
+    unsigned long crc;
+    char *outfile = "env.bin";
+
+    if (argc > 1) {
+        outfile = argv[1];
+    }
+
+    /* Read from stdin */
+    ifp = stdin;
+
+    ofp = fopen(outfile, "w");
+    if (!ofp) {
+        fprintf(stderr, "Failed to open output file: %s\n", outfile);
+        exit(1);
+    }
+
+    env_buffer = malloc(UB_ENV_SIZE);
+    memset(env_buffer, 0xFF, UB_ENV_SIZE);
+
+    /* Skip over the bytes where the CRC is stored */
+    envptr = env_buffer;
+
+    while (fgets(line, LINE_MAX, ifp) != NULL)
+    {
+        int len = strlen(line);
+
+        /* Make sure line will fit, leaving room for the final NUL at the end 
+         * of the env block
+         */
+        if ((envptr + len) >= ((unsigned char *)env_buffer + UB_ENV_SIZE-1))
+        {
+            break;
+        }
+        /* Copy the line, excluding the \n */
+        memcpy(envptr, line, len-1);
+        envptr += len - 1;
+
+        /* Add the separating NUL */
+        *envptr++ = '\0';
+    }
+
+    /* Append the final NUL */
+    *envptr = '\0';
+
+    /* Calculate the CRC */
+    crc = crc32(0, env_buffer, UB_ENV_SIZE);
+#if 0
+    fprintf(stderr,"crc from %X for %X: %X\n", (unsigned long)env_buffer, UB_ENV_SIZE, crc);
+#endif
+
+    // Write the 'active' environment first
+    fputc( crc        & 0xFF, ofp);
+    fputc((crc >>  8) & 0xFF, ofp);
+    fputc((crc >> 16) & 0xFF, ofp);
+    fputc((crc >> 24) & 0xFF, ofp);
+    
+    fputc( 0x01, ofp); // Active flash partition
+
+    /* Write the completed buffer to output file */
+    fwrite(env_buffer, UB_ENV_SIZE, 1, ofp);
+
+    // Now write the 'inactive' environment first
+    fputc( crc        & 0xFF, ofp);
+    fputc((crc >>  8) & 0xFF, ofp);
+    fputc((crc >> 16) & 0xFF, ofp);
+    fputc((crc >> 24) & 0xFF, ofp);
+    
+    fputc( 0x00, ofp); // Inactive flash partition
+
+    /* Write the completed buffer to output file (again) */
+    fwrite(env_buffer, UB_ENV_SIZE, 1, ofp);
+    
+    fclose(ofp);
+
+    free(env_buffer);
+
+    /* success */
+    return 0;
+} /* main() */
